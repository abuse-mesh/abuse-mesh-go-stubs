// Code generated by protoc-gen-go. DO NOT EDIT.
// source: abuse-mesh.proto

/*
Package abusemesh is a generated protocol buffer package.

It is generated from these files:
	abuse-mesh.proto

It has these top-level messages:
	GetNodeRequest
	GetNodeTableRequest
	GetNeighborTableRequest
	GetReportTableRequest
	GetDelistRequestTableRequest
	GetDelistAcceptanceTableRequest
	TableUpdateStreamRequest
	GetNodeTableResponse
	GetNeighborTableResponse
	GetReportTableResponse
	GetDelistRequestTableResponse
	GetDelistAcceptanceTableResponse
	TableUpdate
	IPAddress
	IPRange
	UUID
	Neighbor
	Node
	ContactDetails
	PGPEntity
	PGPIdentity
	PGPSignature
	PGPSubkey
	Report
	ReportConformation
	AbuseDetectionMethod
	Evidence
	DelistRequest
	DelistAcceptance
	DelistAcceptanceMethod
*/
package abusemesh

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The type of update to a table
type TableUpdateType int32

const (
	// A new entity is added to the table
	TableUpdateType_TABLE_UPDATE_NEW TableUpdateType = 0
	// A existing entity was changed in the table
	TableUpdateType_TABLE_UPDATE_EDIT TableUpdateType = 1
	// A entity was deleted from the table
	TableUpdateType_TABLE_UPDATE_DELETE TableUpdateType = 2
)

var TableUpdateType_name = map[int32]string{
	0: "TABLE_UPDATE_NEW",
	1: "TABLE_UPDATE_EDIT",
	2: "TABLE_UPDATE_DELETE",
}
var TableUpdateType_value = map[string]int32{
	"TABLE_UPDATE_NEW":    0,
	"TABLE_UPDATE_EDIT":   1,
	"TABLE_UPDATE_DELETE": 2,
}

func (x TableUpdateType) String() string {
	return proto.EnumName(TableUpdateType_name, int32(x))
}
func (TableUpdateType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type IPAddressFamily int32

const (
	IPAddressFamily_IPFAMILY_IPV4 IPAddressFamily = 0
	IPAddressFamily_IPFAMILY_IPV6 IPAddressFamily = 1
)

var IPAddressFamily_name = map[int32]string{
	0: "IPFAMILY_IPV4",
	1: "IPFAMILY_IPV6",
}
var IPAddressFamily_value = map[string]int32{
	"IPFAMILY_IPV4": 0,
	"IPFAMILY_IPV6": 1,
}

func (x IPAddressFamily) String() string {
	return proto.EnumName(IPAddressFamily_name, int32(x))
}
func (IPAddressFamily) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type AbuseDetectionMethodType int32

const (
	// TODO add standardized detection method types
	AbuseDetectionMethodType_ABUSE_DETECTION_MANUAL AbuseDetectionMethodType = 0
)

var AbuseDetectionMethodType_name = map[int32]string{
	0: "ABUSE_DETECTION_MANUAL",
}
var AbuseDetectionMethodType_value = map[string]int32{
	"ABUSE_DETECTION_MANUAL": 0,
}

func (x AbuseDetectionMethodType) String() string {
	return proto.EnumName(AbuseDetectionMethodType_name, int32(x))
}
func (AbuseDetectionMethodType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type EvidenceType int32

const (
	// TODO add all evidence types
	EvidenceType_EVIDENCE_URL   EvidenceType = 0
	EvidenceType_EVIDENCE_LOG   EvidenceType = 1
	EvidenceType_EVIDENCE_IMAGE EvidenceType = 2
	EvidenceType_EVIDENCE_PCAP  EvidenceType = 3
)

var EvidenceType_name = map[int32]string{
	0: "EVIDENCE_URL",
	1: "EVIDENCE_LOG",
	2: "EVIDENCE_IMAGE",
	3: "EVIDENCE_PCAP",
}
var EvidenceType_value = map[string]int32{
	"EVIDENCE_URL":   0,
	"EVIDENCE_LOG":   1,
	"EVIDENCE_IMAGE": 2,
	"EVIDENCE_PCAP":  3,
}

func (x EvidenceType) String() string {
	return proto.EnumName(EvidenceType_name, int32(x))
}
func (EvidenceType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// NOTE: This list is not complete and probably never will be
// This list must be moderated with the following guidelines:
// 1. General categories, details and variations can be managed with metadata. This keeps the list stable
// 2. Only generally considered abuse, this list should contain acts which are almost unanimously labeled abuse.
//    Very disputable acts like port scanning(at the time of writing this) should be be part of the standard until
//    a great majority of the the community labels it as abuse.
//    However just because one or a few geo political entities allow a act doesn't mean it is not belong on this list
type AbuseType int32

const (
	// A abuse report of spam
	AbuseType_ABUSE_SPAM AbuseType = 0
	// A abuse report of phishing
	AbuseType_ABUSE_PHISHING AbuseType = 1
	// A abuse report of a denial of service attack vector
	AbuseType_ABUSE_DOS AbuseType = 2
	// A abuse report of copyright infringement of any form
	AbuseType_ABUSE_COPYRIGHT_INFRINGEMENT AbuseType = 3
	// A abuse report of content which is against the law in most places
	// e.g. Child Pornography, Hate speech
	// NOTE: This category is not meant for unwanted political content, fake news and other undesirable content which is not illegal
	AbuseType_ABUSE_ILLEGAL_CONTENT AbuseType = 4
	// A abuse report of origin of a hacking attempts which were not requested, promoted or sanctioned by the victim
	AbuseType_ABUSE_UNSANCTIONED_HACKING AbuseType = 5
	// A abuse report of a location on the internet from where computer viruses are distributed
	AbuseType_ABUSE_VIRUS_DISTRIBUTION AbuseType = 6
)

var AbuseType_name = map[int32]string{
	0: "ABUSE_SPAM",
	1: "ABUSE_PHISHING",
	2: "ABUSE_DOS",
	3: "ABUSE_COPYRIGHT_INFRINGEMENT",
	4: "ABUSE_ILLEGAL_CONTENT",
	5: "ABUSE_UNSANCTIONED_HACKING",
	6: "ABUSE_VIRUS_DISTRIBUTION",
}
var AbuseType_value = map[string]int32{
	"ABUSE_SPAM":                   0,
	"ABUSE_PHISHING":               1,
	"ABUSE_DOS":                    2,
	"ABUSE_COPYRIGHT_INFRINGEMENT": 3,
	"ABUSE_ILLEGAL_CONTENT":        4,
	"ABUSE_UNSANCTIONED_HACKING":   5,
	"ABUSE_VIRUS_DISTRIBUTION":     6,
}

func (x AbuseType) String() string {
	return proto.EnumName(AbuseType_name, int32(x))
}
func (AbuseType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type DelistAcceptanceMethodType int32

const (
	// TODO add standardized acceptance methods
	DelistAcceptanceMethodType_DELIST_ACCEPTANCE_MANUAL DelistAcceptanceMethodType = 0
)

var DelistAcceptanceMethodType_name = map[int32]string{
	0: "DELIST_ACCEPTANCE_MANUAL",
}
var DelistAcceptanceMethodType_value = map[string]int32{
	"DELIST_ACCEPTANCE_MANUAL": 0,
}

func (x DelistAcceptanceMethodType) String() string {
	return proto.EnumName(DelistAcceptanceMethodType_name, int32(x))
}
func (DelistAcceptanceMethodType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type GetNodeRequest struct {
}

func (m *GetNodeRequest) Reset()                    { *m = GetNodeRequest{} }
func (m *GetNodeRequest) String() string            { return proto.CompactTextString(m) }
func (*GetNodeRequest) ProtoMessage()               {}
func (*GetNodeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type GetNodeTableRequest struct {
}

func (m *GetNodeTableRequest) Reset()                    { *m = GetNodeTableRequest{} }
func (m *GetNodeTableRequest) String() string            { return proto.CompactTextString(m) }
func (*GetNodeTableRequest) ProtoMessage()               {}
func (*GetNodeTableRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type GetNeighborTableRequest struct {
	// If true the server should return the global neighbor table
	// If false the server should return only its own neighbor table
	Global bool `protobuf:"varint,1,opt,name=global" json:"global,omitempty"`
}

func (m *GetNeighborTableRequest) Reset()                    { *m = GetNeighborTableRequest{} }
func (m *GetNeighborTableRequest) String() string            { return proto.CompactTextString(m) }
func (*GetNeighborTableRequest) ProtoMessage()               {}
func (*GetNeighborTableRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *GetNeighborTableRequest) GetGlobal() bool {
	if m != nil {
		return m.Global
	}
	return false
}

type GetReportTableRequest struct {
}

func (m *GetReportTableRequest) Reset()                    { *m = GetReportTableRequest{} }
func (m *GetReportTableRequest) String() string            { return proto.CompactTextString(m) }
func (*GetReportTableRequest) ProtoMessage()               {}
func (*GetReportTableRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type GetDelistRequestTableRequest struct {
}

func (m *GetDelistRequestTableRequest) Reset()                    { *m = GetDelistRequestTableRequest{} }
func (m *GetDelistRequestTableRequest) String() string            { return proto.CompactTextString(m) }
func (*GetDelistRequestTableRequest) ProtoMessage()               {}
func (*GetDelistRequestTableRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type GetDelistAcceptanceTableRequest struct {
}

func (m *GetDelistAcceptanceTableRequest) Reset()                    { *m = GetDelistAcceptanceTableRequest{} }
func (m *GetDelistAcceptanceTableRequest) String() string            { return proto.CompactTextString(m) }
func (*GetDelistAcceptanceTableRequest) ProtoMessage()               {}
func (*GetDelistAcceptanceTableRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type TableUpdateStreamRequest struct {
}

func (m *TableUpdateStreamRequest) Reset()                    { *m = TableUpdateStreamRequest{} }
func (m *TableUpdateStreamRequest) String() string            { return proto.CompactTextString(m) }
func (*TableUpdateStreamRequest) ProtoMessage()               {}
func (*TableUpdateStreamRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type GetNodeTableResponse struct {
	Nodes []*Node `protobuf:"bytes,1,rep,name=nodes" json:"nodes,omitempty"`
}

func (m *GetNodeTableResponse) Reset()                    { *m = GetNodeTableResponse{} }
func (m *GetNodeTableResponse) String() string            { return proto.CompactTextString(m) }
func (*GetNodeTableResponse) ProtoMessage()               {}
func (*GetNodeTableResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *GetNodeTableResponse) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type GetNeighborTableResponse struct {
	Neighbors []*Neighbor `protobuf:"bytes,1,rep,name=neighbors" json:"neighbors,omitempty"`
}

func (m *GetNeighborTableResponse) Reset()                    { *m = GetNeighborTableResponse{} }
func (m *GetNeighborTableResponse) String() string            { return proto.CompactTextString(m) }
func (*GetNeighborTableResponse) ProtoMessage()               {}
func (*GetNeighborTableResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *GetNeighborTableResponse) GetNeighbors() []*Neighbor {
	if m != nil {
		return m.Neighbors
	}
	return nil
}

type GetReportTableResponse struct {
	Reports []*Report `protobuf:"bytes,1,rep,name=reports" json:"reports,omitempty"`
}

func (m *GetReportTableResponse) Reset()                    { *m = GetReportTableResponse{} }
func (m *GetReportTableResponse) String() string            { return proto.CompactTextString(m) }
func (*GetReportTableResponse) ProtoMessage()               {}
func (*GetReportTableResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *GetReportTableResponse) GetReports() []*Report {
	if m != nil {
		return m.Reports
	}
	return nil
}

type GetDelistRequestTableResponse struct {
	DelistRequests []*DelistRequest `protobuf:"bytes,1,rep,name=delist_requests,json=delistRequests" json:"delist_requests,omitempty"`
}

func (m *GetDelistRequestTableResponse) Reset()                    { *m = GetDelistRequestTableResponse{} }
func (m *GetDelistRequestTableResponse) String() string            { return proto.CompactTextString(m) }
func (*GetDelistRequestTableResponse) ProtoMessage()               {}
func (*GetDelistRequestTableResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *GetDelistRequestTableResponse) GetDelistRequests() []*DelistRequest {
	if m != nil {
		return m.DelistRequests
	}
	return nil
}

type GetDelistAcceptanceTableResponse struct {
	DelistAcceptance []*DelistAcceptance `protobuf:"bytes,1,rep,name=delist_acceptance,json=delistAcceptance" json:"delist_acceptance,omitempty"`
}

func (m *GetDelistAcceptanceTableResponse) Reset()         { *m = GetDelistAcceptanceTableResponse{} }
func (m *GetDelistAcceptanceTableResponse) String() string { return proto.CompactTextString(m) }
func (*GetDelistAcceptanceTableResponse) ProtoMessage()    {}
func (*GetDelistAcceptanceTableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{11}
}

func (m *GetDelistAcceptanceTableResponse) GetDelistAcceptance() []*DelistAcceptance {
	if m != nil {
		return m.DelistAcceptance
	}
	return nil
}

type TableUpdate struct {
	UpdateType TableUpdateType `protobuf:"varint,1,opt,name=update_type,json=updateType,enum=abusemesh.TableUpdateType" json:"update_type,omitempty"`
	// Types that are valid to be assigned to TableEntity:
	//	*TableUpdate_Node
	//	*TableUpdate_Neighbor
	//	*TableUpdate_Report
	//	*TableUpdate_DelistRequests
	//	*TableUpdate_DelistAcceptance
	TableEntity isTableUpdate_TableEntity `protobuf_oneof:"table_entity"`
}

func (m *TableUpdate) Reset()                    { *m = TableUpdate{} }
func (m *TableUpdate) String() string            { return proto.CompactTextString(m) }
func (*TableUpdate) ProtoMessage()               {}
func (*TableUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

type isTableUpdate_TableEntity interface {
	isTableUpdate_TableEntity()
}

type TableUpdate_Node struct {
	Node *Node `protobuf:"bytes,2,opt,name=node,oneof"`
}
type TableUpdate_Neighbor struct {
	Neighbor *Neighbor `protobuf:"bytes,3,opt,name=neighbor,oneof"`
}
type TableUpdate_Report struct {
	Report *Report `protobuf:"bytes,4,opt,name=report,oneof"`
}
type TableUpdate_DelistRequests struct {
	DelistRequests *DelistRequest `protobuf:"bytes,5,opt,name=delist_requests,json=delistRequests,oneof"`
}
type TableUpdate_DelistAcceptance struct {
	DelistAcceptance *DelistAcceptance `protobuf:"bytes,6,opt,name=delist_acceptance,json=delistAcceptance,oneof"`
}

func (*TableUpdate_Node) isTableUpdate_TableEntity()             {}
func (*TableUpdate_Neighbor) isTableUpdate_TableEntity()         {}
func (*TableUpdate_Report) isTableUpdate_TableEntity()           {}
func (*TableUpdate_DelistRequests) isTableUpdate_TableEntity()   {}
func (*TableUpdate_DelistAcceptance) isTableUpdate_TableEntity() {}

func (m *TableUpdate) GetTableEntity() isTableUpdate_TableEntity {
	if m != nil {
		return m.TableEntity
	}
	return nil
}

func (m *TableUpdate) GetUpdateType() TableUpdateType {
	if m != nil {
		return m.UpdateType
	}
	return TableUpdateType_TABLE_UPDATE_NEW
}

func (m *TableUpdate) GetNode() *Node {
	if x, ok := m.GetTableEntity().(*TableUpdate_Node); ok {
		return x.Node
	}
	return nil
}

func (m *TableUpdate) GetNeighbor() *Neighbor {
	if x, ok := m.GetTableEntity().(*TableUpdate_Neighbor); ok {
		return x.Neighbor
	}
	return nil
}

func (m *TableUpdate) GetReport() *Report {
	if x, ok := m.GetTableEntity().(*TableUpdate_Report); ok {
		return x.Report
	}
	return nil
}

func (m *TableUpdate) GetDelistRequests() *DelistRequest {
	if x, ok := m.GetTableEntity().(*TableUpdate_DelistRequests); ok {
		return x.DelistRequests
	}
	return nil
}

func (m *TableUpdate) GetDelistAcceptance() *DelistAcceptance {
	if x, ok := m.GetTableEntity().(*TableUpdate_DelistAcceptance); ok {
		return x.DelistAcceptance
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TableUpdate) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TableUpdate_OneofMarshaler, _TableUpdate_OneofUnmarshaler, _TableUpdate_OneofSizer, []interface{}{
		(*TableUpdate_Node)(nil),
		(*TableUpdate_Neighbor)(nil),
		(*TableUpdate_Report)(nil),
		(*TableUpdate_DelistRequests)(nil),
		(*TableUpdate_DelistAcceptance)(nil),
	}
}

func _TableUpdate_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TableUpdate)
	// table_entity
	switch x := m.TableEntity.(type) {
	case *TableUpdate_Node:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Node); err != nil {
			return err
		}
	case *TableUpdate_Neighbor:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Neighbor); err != nil {
			return err
		}
	case *TableUpdate_Report:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Report); err != nil {
			return err
		}
	case *TableUpdate_DelistRequests:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DelistRequests); err != nil {
			return err
		}
	case *TableUpdate_DelistAcceptance:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DelistAcceptance); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TableUpdate.TableEntity has unexpected type %T", x)
	}
	return nil
}

func _TableUpdate_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TableUpdate)
	switch tag {
	case 2: // table_entity.node
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Node)
		err := b.DecodeMessage(msg)
		m.TableEntity = &TableUpdate_Node{msg}
		return true, err
	case 3: // table_entity.neighbor
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Neighbor)
		err := b.DecodeMessage(msg)
		m.TableEntity = &TableUpdate_Neighbor{msg}
		return true, err
	case 4: // table_entity.report
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Report)
		err := b.DecodeMessage(msg)
		m.TableEntity = &TableUpdate_Report{msg}
		return true, err
	case 5: // table_entity.delist_requests
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DelistRequest)
		err := b.DecodeMessage(msg)
		m.TableEntity = &TableUpdate_DelistRequests{msg}
		return true, err
	case 6: // table_entity.delist_acceptance
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DelistAcceptance)
		err := b.DecodeMessage(msg)
		m.TableEntity = &TableUpdate_DelistAcceptance{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TableUpdate_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TableUpdate)
	// table_entity
	switch x := m.TableEntity.(type) {
	case *TableUpdate_Node:
		s := proto.Size(x.Node)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TableUpdate_Neighbor:
		s := proto.Size(x.Neighbor)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TableUpdate_Report:
		s := proto.Size(x.Report)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TableUpdate_DelistRequests:
		s := proto.Size(x.DelistRequests)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TableUpdate_DelistAcceptance:
		s := proto.Size(x.DelistAcceptance)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type IPAddress struct {
	AddressFamily IPAddressFamily `protobuf:"varint,1,opt,name=address_family,json=addressFamily,enum=abusemesh.IPAddressFamily" json:"address_family,omitempty"`
	Address       string          `protobuf:"bytes,2,opt,name=address" json:"address,omitempty"`
}

func (m *IPAddress) Reset()                    { *m = IPAddress{} }
func (m *IPAddress) String() string            { return proto.CompactTextString(m) }
func (*IPAddress) ProtoMessage()               {}
func (*IPAddress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *IPAddress) GetAddressFamily() IPAddressFamily {
	if m != nil {
		return m.AddressFamily
	}
	return IPAddressFamily_IPFAMILY_IPV4
}

func (m *IPAddress) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type IPRange struct {
	Address *IPAddress `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	Prefix  int32      `protobuf:"varint,2,opt,name=prefix" json:"prefix,omitempty"`
}

func (m *IPRange) Reset()                    { *m = IPRange{} }
func (m *IPRange) String() string            { return proto.CompactTextString(m) }
func (*IPRange) ProtoMessage()               {}
func (*IPRange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *IPRange) GetAddress() *IPAddress {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *IPRange) GetPrefix() int32 {
	if m != nil {
		return m.Prefix
	}
	return 0
}

// UUID (Universally unique identifier)
type UUID struct {
	Uuid string `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
}

func (m *UUID) Reset()                    { *m = UUID{} }
func (m *UUID) String() string            { return proto.CompactTextString(m) }
func (*UUID) ProtoMessage()               {}
func (*UUID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *UUID) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

// A Neighbor is a node the current node has a connection with
type Neighbor struct {
	// The node to which the current node is connected
	Node *Node `protobuf:"bytes,1,opt,name=node" json:"node,omitempty"`
}

func (m *Neighbor) Reset()                    { *m = Neighbor{} }
func (m *Neighbor) String() string            { return proto.CompactTextString(m) }
func (*Neighbor) ProtoMessage()               {}
func (*Neighbor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *Neighbor) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

// A node is a application which speaks the AbuseMesh protocol
type Node struct {
	// The ID of the node
	Uuid *UUID `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// The IP address on which the node is reachable
	IpAddress *IPAddress `protobuf:"bytes,2,opt,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	// Details about how to contact the the company and/of administrators of a node
	ContactDetails *ContactDetails `protobuf:"bytes,3,opt,name=contact_details,json=contactDetails" json:"contact_details,omitempty"`
	// The number of the autonomous system for which this node claims to have authority
	ASN int32 `protobuf:"varint,4,opt,name=ASN" json:"ASN,omitempty"`
	// The PGP entity which the node uses to sign its messages
	PgpEntity *PGPEntity `protobuf:"bytes,5,opt,name=pgp_entity,json=pgpEntity" json:"pgp_entity,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *Node) GetUuid() *UUID {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *Node) GetIpAddress() *IPAddress {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *Node) GetContactDetails() *ContactDetails {
	if m != nil {
		return m.ContactDetails
	}
	return nil
}

func (m *Node) GetASN() int32 {
	if m != nil {
		return m.ASN
	}
	return 0
}

func (m *Node) GetPgpEntity() *PGPEntity {
	if m != nil {
		return m.PgpEntity
	}
	return nil
}

type ContactDetails struct {
	CompanyName     string                   `protobuf:"bytes,1,opt,name=company_name,json=companyName" json:"company_name,omitempty"`
	EmailAddress    string                   `protobuf:"bytes,2,opt,name=email_address,json=emailAddress" json:"email_address,omitempty"`
	PhoneNumber     string                   `protobuf:"bytes,3,opt,name=phone_number,json=phoneNumber" json:"phone_number,omitempty"`
	PhysicalAddress string                   `protobuf:"bytes,4,opt,name=physical_address,json=physicalAddress" json:"physical_address,omitempty"`
	ContactPersons  []*ContactDetails_Person `protobuf:"bytes,5,rep,name=contact_persons,json=contactPersons" json:"contact_persons,omitempty"`
}

func (m *ContactDetails) Reset()                    { *m = ContactDetails{} }
func (m *ContactDetails) String() string            { return proto.CompactTextString(m) }
func (*ContactDetails) ProtoMessage()               {}
func (*ContactDetails) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *ContactDetails) GetCompanyName() string {
	if m != nil {
		return m.CompanyName
	}
	return ""
}

func (m *ContactDetails) GetEmailAddress() string {
	if m != nil {
		return m.EmailAddress
	}
	return ""
}

func (m *ContactDetails) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *ContactDetails) GetPhysicalAddress() string {
	if m != nil {
		return m.PhysicalAddress
	}
	return ""
}

func (m *ContactDetails) GetContactPersons() []*ContactDetails_Person {
	if m != nil {
		return m.ContactPersons
	}
	return nil
}

type ContactDetails_Person struct {
	FirstName    string `protobuf:"bytes,6,opt,name=first_name,json=firstName" json:"first_name,omitempty"`
	MiddleName   string `protobuf:"bytes,7,opt,name=middle_name,json=middleName" json:"middle_name,omitempty"`
	LastName     string `protobuf:"bytes,8,opt,name=last_name,json=lastName" json:"last_name,omitempty"`
	JobTitle     string `protobuf:"bytes,9,opt,name=job_title,json=jobTitle" json:"job_title,omitempty"`
	EmailAddress string `protobuf:"bytes,10,opt,name=email_address,json=emailAddress" json:"email_address,omitempty"`
	PhoneNumber  string `protobuf:"bytes,11,opt,name=phone_number,json=phoneNumber" json:"phone_number,omitempty"`
}

func (m *ContactDetails_Person) Reset()                    { *m = ContactDetails_Person{} }
func (m *ContactDetails_Person) String() string            { return proto.CompactTextString(m) }
func (*ContactDetails_Person) ProtoMessage()               {}
func (*ContactDetails_Person) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18, 0} }

func (m *ContactDetails_Person) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *ContactDetails_Person) GetMiddleName() string {
	if m != nil {
		return m.MiddleName
	}
	return ""
}

func (m *ContactDetails_Person) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *ContactDetails_Person) GetJobTitle() string {
	if m != nil {
		return m.JobTitle
	}
	return ""
}

func (m *ContactDetails_Person) GetEmailAddress() string {
	if m != nil {
		return m.EmailAddress
	}
	return ""
}

func (m *ContactDetails_Person) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

type PGPEntity struct {
	// Public key of the entity in ASCII-Armor format
	PublicKey string `protobuf:"bytes,1,opt,name=public_key,json=publicKey" json:"public_key,omitempty"`
	// All identities that claim to be this key
	Identities []*PGPIdentity `protobuf:"bytes,2,rep,name=identities" json:"identities,omitempty"`
	// All subkeys of this master key
	Subkeys []*PGPSubkey `protobuf:"bytes,3,rep,name=subkeys" json:"subkeys,omitempty"`
}

func (m *PGPEntity) Reset()                    { *m = PGPEntity{} }
func (m *PGPEntity) String() string            { return proto.CompactTextString(m) }
func (*PGPEntity) ProtoMessage()               {}
func (*PGPEntity) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *PGPEntity) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

func (m *PGPEntity) GetIdentities() []*PGPIdentity {
	if m != nil {
		return m.Identities
	}
	return nil
}

func (m *PGPEntity) GetSubkeys() []*PGPSubkey {
	if m != nil {
		return m.Subkeys
	}
	return nil
}

type PGPIdentity struct {
	// The user identifier, e.g. Serverius B.V. (833af263-57b8-49f5-b679-12164db5a439) <abuse@serverius.net>
	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	// A user identity verification signature signed by the key this identity belongs to
	SelfSignature *PGPSignature `protobuf:"bytes,2,opt,name=self_signature,json=selfSignature" json:"self_signature,omitempty"`
	// A list of identity verification signatures signed by other nodes to confirm this is the identity of the key/node
	Signatures []*PGPSignature `protobuf:"bytes,3,rep,name=signatures" json:"signatures,omitempty"`
}

func (m *PGPIdentity) Reset()                    { *m = PGPIdentity{} }
func (m *PGPIdentity) String() string            { return proto.CompactTextString(m) }
func (*PGPIdentity) ProtoMessage()               {}
func (*PGPIdentity) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *PGPIdentity) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *PGPIdentity) GetSelfSignature() *PGPSignature {
	if m != nil {
		return m.SelfSignature
	}
	return nil
}

func (m *PGPIdentity) GetSignatures() []*PGPSignature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

type PGPSignature struct {
	// Signature in ASCII-Armor format
	Signature string `protobuf:"bytes,1,opt,name=signature" json:"signature,omitempty"`
}

func (m *PGPSignature) Reset()                    { *m = PGPSignature{} }
func (m *PGPSignature) String() string            { return proto.CompactTextString(m) }
func (*PGPSignature) ProtoMessage()               {}
func (*PGPSignature) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *PGPSignature) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

type PGPSubkey struct {
	// public key of the subkey in ASCII-Armor format
	PublicKey string `protobuf:"bytes,1,opt,name=public_key,json=publicKey" json:"public_key,omitempty"`
	// A signature signed with the master key to prove this key is a subkey of the master key
	Signature *PGPSignature `protobuf:"bytes,2,opt,name=signature" json:"signature,omitempty"`
}

func (m *PGPSubkey) Reset()                    { *m = PGPSubkey{} }
func (m *PGPSubkey) String() string            { return proto.CompactTextString(m) }
func (*PGPSubkey) ProtoMessage()               {}
func (*PGPSubkey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *PGPSubkey) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

func (m *PGPSubkey) GetSignature() *PGPSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

type Report struct {
	// The id of the report
	Uuid *UUID `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// The id of the node which created the report
	Reporter *UUID `protobuf:"bytes,2,opt,name=reporter" json:"reporter,omitempty"`
	// The id of the node which claims ownership over the AS where the abuse originated
	Suspect *UUID `protobuf:"bytes,3,opt,name=suspect" json:"suspect,omitempty"`
	// The signature that proves the reporter it the author of the report and that the report has no been modified
	Signature *PGPSignature `protobuf:"bytes,4,opt,name=signature" json:"signature,omitempty"`
	// The type of abuse this report specifies
	//
	// Types that are valid to be assigned to ReportAbuseType:
	//	*Report_UnstandardizedAbuseType
	//	*Report_AbuseType
	ReportAbuseType isReport_ReportAbuseType `protobuf_oneof:"report_abuse_type"`
	// A human readable description to give context
	// WARNING: this field should not be used for evidence, metadata or other machine data.
	Description string `protobuf:"bytes,7,opt,name=description" json:"description,omitempty"`
	// Types that are valid to be assigned to AbuseOrigin:
	//	*Report_Email
	//	*Report_DomainName
	//	*Report_Url
	//	*Report_Ip
	//	*Report_IpRange
	AbuseOrigin isReport_AbuseOrigin `protobuf_oneof:"abuse_origin"`
	// A key value map of evidence of abuse
	// e.g. when reporting spam, the recieved email can be included
	// e.g. for illegal scanning a log can be included
	// e.g. when reporting a DoS attack a anonymised PCAP can be included
	Evidence map[string]*Evidence `protobuf:"bytes,13,rep,name=evidence" json:"evidence,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// A map containing extra details about the abuse type
	// e.g. when reporting a DoS attack the type of DOS attack can be a metadata field
	// TODO maybe this should be standardized as well at some point
	AbuseTypeMetadata map[string]string `protobuf:"bytes,14,rep,name=abuse_type_metadata,json=abuseTypeMetadata" json:"abuse_type_metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// How was the abuse detected
	// e.g. spam filter
	// e.g. DDoS detector
	// e.g. human entry
	DetectionMethod *AbuseDetectionMethod `protobuf:"bytes,15,opt,name=detection_method,json=detectionMethod" json:"detection_method,omitempty"`
	// A map containing extra details about the detection method
	// e.g. which software version was used to detect the abuse
	// e.g. who created this report manually
	// TODO maybe this should be standardized as well at some point
	DetectionMethodMetadata map[string]string `protobuf:"bytes,16,rep,name=detection_method_metadata,json=detectionMethodMetadata" json:"detection_method_metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Report) Reset()                    { *m = Report{} }
func (m *Report) String() string            { return proto.CompactTextString(m) }
func (*Report) ProtoMessage()               {}
func (*Report) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

type isReport_ReportAbuseType interface {
	isReport_ReportAbuseType()
}
type isReport_AbuseOrigin interface {
	isReport_AbuseOrigin()
}

type Report_UnstandardizedAbuseType struct {
	UnstandardizedAbuseType string `protobuf:"bytes,5,opt,name=unstandardized_abuse_type,json=unstandardizedAbuseType,oneof"`
}
type Report_AbuseType struct {
	AbuseType AbuseType `protobuf:"varint,6,opt,name=abuse_type,json=abuseType,enum=abusemesh.AbuseType,oneof"`
}
type Report_Email struct {
	Email string `protobuf:"bytes,8,opt,name=email,oneof"`
}
type Report_DomainName struct {
	DomainName string `protobuf:"bytes,9,opt,name=domain_name,json=domainName,oneof"`
}
type Report_Url struct {
	Url string `protobuf:"bytes,10,opt,name=url,oneof"`
}
type Report_Ip struct {
	Ip *IPAddress `protobuf:"bytes,11,opt,name=ip,oneof"`
}
type Report_IpRange struct {
	IpRange *IPRange `protobuf:"bytes,12,opt,name=ip_range,json=ipRange,oneof"`
}

func (*Report_UnstandardizedAbuseType) isReport_ReportAbuseType() {}
func (*Report_AbuseType) isReport_ReportAbuseType()               {}
func (*Report_Email) isReport_AbuseOrigin()                       {}
func (*Report_DomainName) isReport_AbuseOrigin()                  {}
func (*Report_Url) isReport_AbuseOrigin()                         {}
func (*Report_Ip) isReport_AbuseOrigin()                          {}
func (*Report_IpRange) isReport_AbuseOrigin()                     {}

func (m *Report) GetReportAbuseType() isReport_ReportAbuseType {
	if m != nil {
		return m.ReportAbuseType
	}
	return nil
}
func (m *Report) GetAbuseOrigin() isReport_AbuseOrigin {
	if m != nil {
		return m.AbuseOrigin
	}
	return nil
}

func (m *Report) GetUuid() *UUID {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *Report) GetReporter() *UUID {
	if m != nil {
		return m.Reporter
	}
	return nil
}

func (m *Report) GetSuspect() *UUID {
	if m != nil {
		return m.Suspect
	}
	return nil
}

func (m *Report) GetSignature() *PGPSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Report) GetUnstandardizedAbuseType() string {
	if x, ok := m.GetReportAbuseType().(*Report_UnstandardizedAbuseType); ok {
		return x.UnstandardizedAbuseType
	}
	return ""
}

func (m *Report) GetAbuseType() AbuseType {
	if x, ok := m.GetReportAbuseType().(*Report_AbuseType); ok {
		return x.AbuseType
	}
	return AbuseType_ABUSE_SPAM
}

func (m *Report) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Report) GetEmail() string {
	if x, ok := m.GetAbuseOrigin().(*Report_Email); ok {
		return x.Email
	}
	return ""
}

func (m *Report) GetDomainName() string {
	if x, ok := m.GetAbuseOrigin().(*Report_DomainName); ok {
		return x.DomainName
	}
	return ""
}

func (m *Report) GetUrl() string {
	if x, ok := m.GetAbuseOrigin().(*Report_Url); ok {
		return x.Url
	}
	return ""
}

func (m *Report) GetIp() *IPAddress {
	if x, ok := m.GetAbuseOrigin().(*Report_Ip); ok {
		return x.Ip
	}
	return nil
}

func (m *Report) GetIpRange() *IPRange {
	if x, ok := m.GetAbuseOrigin().(*Report_IpRange); ok {
		return x.IpRange
	}
	return nil
}

func (m *Report) GetEvidence() map[string]*Evidence {
	if m != nil {
		return m.Evidence
	}
	return nil
}

func (m *Report) GetAbuseTypeMetadata() map[string]string {
	if m != nil {
		return m.AbuseTypeMetadata
	}
	return nil
}

func (m *Report) GetDetectionMethod() *AbuseDetectionMethod {
	if m != nil {
		return m.DetectionMethod
	}
	return nil
}

func (m *Report) GetDetectionMethodMetadata() map[string]string {
	if m != nil {
		return m.DetectionMethodMetadata
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Report) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Report_OneofMarshaler, _Report_OneofUnmarshaler, _Report_OneofSizer, []interface{}{
		(*Report_UnstandardizedAbuseType)(nil),
		(*Report_AbuseType)(nil),
		(*Report_Email)(nil),
		(*Report_DomainName)(nil),
		(*Report_Url)(nil),
		(*Report_Ip)(nil),
		(*Report_IpRange)(nil),
	}
}

func _Report_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Report)
	// report_abuse_type
	switch x := m.ReportAbuseType.(type) {
	case *Report_UnstandardizedAbuseType:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.UnstandardizedAbuseType)
	case *Report_AbuseType:
		b.EncodeVarint(6<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.AbuseType))
	case nil:
	default:
		return fmt.Errorf("Report.ReportAbuseType has unexpected type %T", x)
	}
	// abuse_origin
	switch x := m.AbuseOrigin.(type) {
	case *Report_Email:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Email)
	case *Report_DomainName:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.DomainName)
	case *Report_Url:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Url)
	case *Report_Ip:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ip); err != nil {
			return err
		}
	case *Report_IpRange:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpRange); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Report.AbuseOrigin has unexpected type %T", x)
	}
	return nil
}

func _Report_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Report)
	switch tag {
	case 5: // report_abuse_type.unstandardized_abuse_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ReportAbuseType = &Report_UnstandardizedAbuseType{x}
		return true, err
	case 6: // report_abuse_type.abuse_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ReportAbuseType = &Report_AbuseType{AbuseType(x)}
		return true, err
	case 8: // abuse_origin.email
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.AbuseOrigin = &Report_Email{x}
		return true, err
	case 9: // abuse_origin.domain_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.AbuseOrigin = &Report_DomainName{x}
		return true, err
	case 10: // abuse_origin.url
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.AbuseOrigin = &Report_Url{x}
		return true, err
	case 11: // abuse_origin.ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPAddress)
		err := b.DecodeMessage(msg)
		m.AbuseOrigin = &Report_Ip{msg}
		return true, err
	case 12: // abuse_origin.ip_range
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPRange)
		err := b.DecodeMessage(msg)
		m.AbuseOrigin = &Report_IpRange{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Report_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Report)
	// report_abuse_type
	switch x := m.ReportAbuseType.(type) {
	case *Report_UnstandardizedAbuseType:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.UnstandardizedAbuseType)))
		n += len(x.UnstandardizedAbuseType)
	case *Report_AbuseType:
		n += proto.SizeVarint(6<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.AbuseType))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// abuse_origin
	switch x := m.AbuseOrigin.(type) {
	case *Report_Email:
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Email)))
		n += len(x.Email)
	case *Report_DomainName:
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.DomainName)))
		n += len(x.DomainName)
	case *Report_Url:
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Url)))
		n += len(x.Url)
	case *Report_Ip:
		s := proto.Size(x.Ip)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Report_IpRange:
		s := proto.Size(x.IpRange)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A report conformation can be created by a node which claims to have checked the report indepenantly and confirms the abuse report
// A report conformation therefor must also provide evidence
type ReportConformation struct {
	// The id of the report conformation
	Uuid *UUID `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// The id of node that created the confirmation
	Node *UUID `protobuf:"bytes,2,opt,name=node" json:"node,omitempty"`
	// The id of the report that is confirmed by this message
	Report *UUID `protobuf:"bytes,3,opt,name=report" json:"report,omitempty"`
	// The signature that proves the reporter it the author of the report and that the report has not been modified
	Signature *PGPSignature `protobuf:"bytes,4,opt,name=signature" json:"signature,omitempty"`
	// A human readable description of the conformation
	// WARNING: this field should not be used for evidence or other machine data.
	Description string `protobuf:"bytes,5,opt,name=description" json:"description,omitempty"`
	// A key value map of evidence of abuse which should be indepently gathered
	// e.g. when reporting copyright infringement a http request and response can be added
	// e.g. when reporting a DoS attack a anonymised PCAP can be included
	Evidence map[string]*Evidence `protobuf:"bytes,6,rep,name=evidence" json:"evidence,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// How was the abuse detected
	// e.g. spam filter
	// e.g. DDoS detector
	// e.g. human entry
	DetectionMethod *AbuseDetectionMethod `protobuf:"bytes,7,opt,name=detection_method,json=detectionMethod" json:"detection_method,omitempty"`
	// A map containing extra details about the detection method
	// e.g. which software version was used to detect the abuse
	// e.g. who created this report manually
	// TODO maybe this should be standardized as well at some point
	DetectionMethodMetadata map[string]string `protobuf:"bytes,8,rep,name=detection_method_metadata,json=detectionMethodMetadata" json:"detection_method_metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ReportConformation) Reset()                    { *m = ReportConformation{} }
func (m *ReportConformation) String() string            { return proto.CompactTextString(m) }
func (*ReportConformation) ProtoMessage()               {}
func (*ReportConformation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *ReportConformation) GetUuid() *UUID {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *ReportConformation) GetNode() *UUID {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *ReportConformation) GetReport() *UUID {
	if m != nil {
		return m.Report
	}
	return nil
}

func (m *ReportConformation) GetSignature() *PGPSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *ReportConformation) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ReportConformation) GetEvidence() map[string]*Evidence {
	if m != nil {
		return m.Evidence
	}
	return nil
}

func (m *ReportConformation) GetDetectionMethod() *AbuseDetectionMethod {
	if m != nil {
		return m.DetectionMethod
	}
	return nil
}

func (m *ReportConformation) GetDetectionMethodMetadata() map[string]string {
	if m != nil {
		return m.DetectionMethodMetadata
	}
	return nil
}

type AbuseDetectionMethod struct {
	// Types that are valid to be assigned to DetectionMethod:
	//	*AbuseDetectionMethod_UnstandardizedDetectionMethod
	//	*AbuseDetectionMethod_DetectionMethodType
	DetectionMethod isAbuseDetectionMethod_DetectionMethod `protobuf_oneof:"detection_method"`
}

func (m *AbuseDetectionMethod) Reset()                    { *m = AbuseDetectionMethod{} }
func (m *AbuseDetectionMethod) String() string            { return proto.CompactTextString(m) }
func (*AbuseDetectionMethod) ProtoMessage()               {}
func (*AbuseDetectionMethod) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

type isAbuseDetectionMethod_DetectionMethod interface {
	isAbuseDetectionMethod_DetectionMethod()
}

type AbuseDetectionMethod_UnstandardizedDetectionMethod struct {
	UnstandardizedDetectionMethod string `protobuf:"bytes,1,opt,name=unstandardized_detection_method,json=unstandardizedDetectionMethod,oneof"`
}
type AbuseDetectionMethod_DetectionMethodType struct {
	DetectionMethodType AbuseDetectionMethodType `protobuf:"varint,2,opt,name=detection_method_type,json=detectionMethodType,enum=abusemesh.AbuseDetectionMethodType,oneof"`
}

func (*AbuseDetectionMethod_UnstandardizedDetectionMethod) isAbuseDetectionMethod_DetectionMethod() {}
func (*AbuseDetectionMethod_DetectionMethodType) isAbuseDetectionMethod_DetectionMethod()           {}

func (m *AbuseDetectionMethod) GetDetectionMethod() isAbuseDetectionMethod_DetectionMethod {
	if m != nil {
		return m.DetectionMethod
	}
	return nil
}

func (m *AbuseDetectionMethod) GetUnstandardizedDetectionMethod() string {
	if x, ok := m.GetDetectionMethod().(*AbuseDetectionMethod_UnstandardizedDetectionMethod); ok {
		return x.UnstandardizedDetectionMethod
	}
	return ""
}

func (m *AbuseDetectionMethod) GetDetectionMethodType() AbuseDetectionMethodType {
	if x, ok := m.GetDetectionMethod().(*AbuseDetectionMethod_DetectionMethodType); ok {
		return x.DetectionMethodType
	}
	return AbuseDetectionMethodType_ABUSE_DETECTION_MANUAL
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AbuseDetectionMethod) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AbuseDetectionMethod_OneofMarshaler, _AbuseDetectionMethod_OneofUnmarshaler, _AbuseDetectionMethod_OneofSizer, []interface{}{
		(*AbuseDetectionMethod_UnstandardizedDetectionMethod)(nil),
		(*AbuseDetectionMethod_DetectionMethodType)(nil),
	}
}

func _AbuseDetectionMethod_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AbuseDetectionMethod)
	// detection_method
	switch x := m.DetectionMethod.(type) {
	case *AbuseDetectionMethod_UnstandardizedDetectionMethod:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.UnstandardizedDetectionMethod)
	case *AbuseDetectionMethod_DetectionMethodType:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.DetectionMethodType))
	case nil:
	default:
		return fmt.Errorf("AbuseDetectionMethod.DetectionMethod has unexpected type %T", x)
	}
	return nil
}

func _AbuseDetectionMethod_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AbuseDetectionMethod)
	switch tag {
	case 1: // detection_method.unstandardized_detection_method
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.DetectionMethod = &AbuseDetectionMethod_UnstandardizedDetectionMethod{x}
		return true, err
	case 2: // detection_method.detection_method_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.DetectionMethod = &AbuseDetectionMethod_DetectionMethodType{AbuseDetectionMethodType(x)}
		return true, err
	default:
		return false, nil
	}
}

func _AbuseDetectionMethod_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AbuseDetectionMethod)
	// detection_method
	switch x := m.DetectionMethod.(type) {
	case *AbuseDetectionMethod_UnstandardizedDetectionMethod:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.UnstandardizedDetectionMethod)))
		n += len(x.UnstandardizedDetectionMethod)
	case *AbuseDetectionMethod_DetectionMethodType:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.DetectionMethodType))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Evidence struct {
	// Types that are valid to be assigned to EvidenceType:
	//	*Evidence_UnstandardizedEvidenceType
	//	*Evidence_Type
	EvidenceType isEvidence_EvidenceType `protobuf_oneof:"evidence_type"`
	EvidenceData []byte                  `protobuf:"bytes,3,opt,name=evidence_data,json=evidenceData,proto3" json:"evidence_data,omitempty"`
}

func (m *Evidence) Reset()                    { *m = Evidence{} }
func (m *Evidence) String() string            { return proto.CompactTextString(m) }
func (*Evidence) ProtoMessage()               {}
func (*Evidence) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

type isEvidence_EvidenceType interface {
	isEvidence_EvidenceType()
}

type Evidence_UnstandardizedEvidenceType struct {
	UnstandardizedEvidenceType string `protobuf:"bytes,1,opt,name=unstandardized_evidence_type,json=unstandardizedEvidenceType,oneof"`
}
type Evidence_Type struct {
	Type EvidenceType `protobuf:"varint,2,opt,name=type,enum=abusemesh.EvidenceType,oneof"`
}

func (*Evidence_UnstandardizedEvidenceType) isEvidence_EvidenceType() {}
func (*Evidence_Type) isEvidence_EvidenceType()                       {}

func (m *Evidence) GetEvidenceType() isEvidence_EvidenceType {
	if m != nil {
		return m.EvidenceType
	}
	return nil
}

func (m *Evidence) GetUnstandardizedEvidenceType() string {
	if x, ok := m.GetEvidenceType().(*Evidence_UnstandardizedEvidenceType); ok {
		return x.UnstandardizedEvidenceType
	}
	return ""
}

func (m *Evidence) GetType() EvidenceType {
	if x, ok := m.GetEvidenceType().(*Evidence_Type); ok {
		return x.Type
	}
	return EvidenceType_EVIDENCE_URL
}

func (m *Evidence) GetEvidenceData() []byte {
	if m != nil {
		return m.EvidenceData
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Evidence) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Evidence_OneofMarshaler, _Evidence_OneofUnmarshaler, _Evidence_OneofSizer, []interface{}{
		(*Evidence_UnstandardizedEvidenceType)(nil),
		(*Evidence_Type)(nil),
	}
}

func _Evidence_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Evidence)
	// evidence_type
	switch x := m.EvidenceType.(type) {
	case *Evidence_UnstandardizedEvidenceType:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.UnstandardizedEvidenceType)
	case *Evidence_Type:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Type))
	case nil:
	default:
		return fmt.Errorf("Evidence.EvidenceType has unexpected type %T", x)
	}
	return nil
}

func _Evidence_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Evidence)
	switch tag {
	case 1: // evidence_type.unstandardized_evidence_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.EvidenceType = &Evidence_UnstandardizedEvidenceType{x}
		return true, err
	case 2: // evidence_type.type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.EvidenceType = &Evidence_Type{EvidenceType(x)}
		return true, err
	default:
		return false, nil
	}
}

func _Evidence_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Evidence)
	// evidence_type
	switch x := m.EvidenceType.(type) {
	case *Evidence_UnstandardizedEvidenceType:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.UnstandardizedEvidenceType)))
		n += len(x.UnstandardizedEvidenceType)
	case *Evidence_Type:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Type))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type DelistRequest struct {
	// The id of the delist request
	Uuid *UUID `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// The report to be delisted
	Report *UUID `protobuf:"bytes,2,opt,name=report" json:"report,omitempty"`
	// The node which requested the delisting
	Node *Node `protobuf:"bytes,3,opt,name=node" json:"node,omitempty"`
	// The signature that proves the requester it the author of the delist request and that the delist request has not been modified
	Signature *PGPSignature `protobuf:"bytes,4,opt,name=signature" json:"signature,omitempty"`
	// A human readable description which may explain why a report is incorrect or has been resolved
	Description string `protobuf:"bytes,5,opt,name=description" json:"description,omitempty"`
	// A key value map of evidence which proves a report is incorrect or resolved
	// e.g. a letter of consent when appealing a scanning abuse report
	// e.g. a link to a court case
	Evidence map[string]*Evidence `protobuf:"bytes,6,rep,name=evidence" json:"evidence,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// A map containing extra details
	// e.g. when reporting a DOS attack the type of DOS attack can be a metadata field
	// TODO maybe this should be standardized as well at some point
	Metadata map[string]string `protobuf:"bytes,7,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *DelistRequest) Reset()                    { *m = DelistRequest{} }
func (m *DelistRequest) String() string            { return proto.CompactTextString(m) }
func (*DelistRequest) ProtoMessage()               {}
func (*DelistRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *DelistRequest) GetUuid() *UUID {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *DelistRequest) GetReport() *UUID {
	if m != nil {
		return m.Report
	}
	return nil
}

func (m *DelistRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *DelistRequest) GetSignature() *PGPSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *DelistRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *DelistRequest) GetEvidence() map[string]*Evidence {
	if m != nil {
		return m.Evidence
	}
	return nil
}

func (m *DelistRequest) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type DelistAcceptance struct {
	// The id of the delist acceptance
	Uuid *UUID `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// The id of the delist request
	DelistRequest *UUID `protobuf:"bytes,2,opt,name=delist_request,json=delistRequest" json:"delist_request,omitempty"`
	// The node which accepted the delisting request
	Node *Node `protobuf:"bytes,3,opt,name=node" json:"node,omitempty"`
	// The signature that proves the node it the author of the delist acceptance and that the delist acceptance has not been modified
	Signature *PGPSignature `protobuf:"bytes,4,opt,name=signature" json:"signature,omitempty"`
	// A human readable description which may explain why the delist request was accepted
	Description string `protobuf:"bytes,5,opt,name=description" json:"description,omitempty"`
	// A key value map of evidence which proves a report is incorrect or resolved
	// e.g. http request and response to a url which now returns a 404 in case of copyright infringement
	Evidence map[string]*Evidence `protobuf:"bytes,6,rep,name=evidence" json:"evidence,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The method which was used to accept this method
	// e.g. manual(human check)
	// e.g. automated copyright check tool
	AcceptanceMethod *DelistAcceptanceMethod `protobuf:"bytes,7,opt,name=acceptance_method,json=acceptanceMethod" json:"acceptance_method,omitempty"`
	// A map containing extra details about the acceptance method
	// e.g. what is the name, version and source code of a scanner
	// e.g. Which human checked the delist request
	// TODO maybe this should be standardized as well at some point
	AcceptanceMethodMetadata map[string]string `protobuf:"bytes,8,rep,name=acceptance_method_metadata,json=acceptanceMethodMetadata" json:"acceptance_method_metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *DelistAcceptance) Reset()                    { *m = DelistAcceptance{} }
func (m *DelistAcceptance) String() string            { return proto.CompactTextString(m) }
func (*DelistAcceptance) ProtoMessage()               {}
func (*DelistAcceptance) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *DelistAcceptance) GetUuid() *UUID {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *DelistAcceptance) GetDelistRequest() *UUID {
	if m != nil {
		return m.DelistRequest
	}
	return nil
}

func (m *DelistAcceptance) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *DelistAcceptance) GetSignature() *PGPSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *DelistAcceptance) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *DelistAcceptance) GetEvidence() map[string]*Evidence {
	if m != nil {
		return m.Evidence
	}
	return nil
}

func (m *DelistAcceptance) GetAcceptanceMethod() *DelistAcceptanceMethod {
	if m != nil {
		return m.AcceptanceMethod
	}
	return nil
}

func (m *DelistAcceptance) GetAcceptanceMethodMetadata() map[string]string {
	if m != nil {
		return m.AcceptanceMethodMetadata
	}
	return nil
}

type DelistAcceptanceMethod struct {
	// Types that are valid to be assigned to AcceptanceMethod:
	//	*DelistAcceptanceMethod_UnstandardizedAcceptanceMethodType
	//	*DelistAcceptanceMethod_MethodType
	AcceptanceMethod isDelistAcceptanceMethod_AcceptanceMethod `protobuf_oneof:"acceptance_method"`
}

func (m *DelistAcceptanceMethod) Reset()                    { *m = DelistAcceptanceMethod{} }
func (m *DelistAcceptanceMethod) String() string            { return proto.CompactTextString(m) }
func (*DelistAcceptanceMethod) ProtoMessage()               {}
func (*DelistAcceptanceMethod) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

type isDelistAcceptanceMethod_AcceptanceMethod interface {
	isDelistAcceptanceMethod_AcceptanceMethod()
}

type DelistAcceptanceMethod_UnstandardizedAcceptanceMethodType struct {
	UnstandardizedAcceptanceMethodType string `protobuf:"bytes,1,opt,name=unstandardized_acceptance_method_type,json=unstandardizedAcceptanceMethodType,oneof"`
}
type DelistAcceptanceMethod_MethodType struct {
	MethodType DelistAcceptanceMethodType `protobuf:"varint,2,opt,name=method_type,json=methodType,enum=abusemesh.DelistAcceptanceMethodType,oneof"`
}

func (*DelistAcceptanceMethod_UnstandardizedAcceptanceMethodType) isDelistAcceptanceMethod_AcceptanceMethod() {
}
func (*DelistAcceptanceMethod_MethodType) isDelistAcceptanceMethod_AcceptanceMethod() {}

func (m *DelistAcceptanceMethod) GetAcceptanceMethod() isDelistAcceptanceMethod_AcceptanceMethod {
	if m != nil {
		return m.AcceptanceMethod
	}
	return nil
}

func (m *DelistAcceptanceMethod) GetUnstandardizedAcceptanceMethodType() string {
	if x, ok := m.GetAcceptanceMethod().(*DelistAcceptanceMethod_UnstandardizedAcceptanceMethodType); ok {
		return x.UnstandardizedAcceptanceMethodType
	}
	return ""
}

func (m *DelistAcceptanceMethod) GetMethodType() DelistAcceptanceMethodType {
	if x, ok := m.GetAcceptanceMethod().(*DelistAcceptanceMethod_MethodType); ok {
		return x.MethodType
	}
	return DelistAcceptanceMethodType_DELIST_ACCEPTANCE_MANUAL
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DelistAcceptanceMethod) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DelistAcceptanceMethod_OneofMarshaler, _DelistAcceptanceMethod_OneofUnmarshaler, _DelistAcceptanceMethod_OneofSizer, []interface{}{
		(*DelistAcceptanceMethod_UnstandardizedAcceptanceMethodType)(nil),
		(*DelistAcceptanceMethod_MethodType)(nil),
	}
}

func _DelistAcceptanceMethod_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DelistAcceptanceMethod)
	// acceptance_method
	switch x := m.AcceptanceMethod.(type) {
	case *DelistAcceptanceMethod_UnstandardizedAcceptanceMethodType:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.UnstandardizedAcceptanceMethodType)
	case *DelistAcceptanceMethod_MethodType:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.MethodType))
	case nil:
	default:
		return fmt.Errorf("DelistAcceptanceMethod.AcceptanceMethod has unexpected type %T", x)
	}
	return nil
}

func _DelistAcceptanceMethod_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DelistAcceptanceMethod)
	switch tag {
	case 1: // acceptance_method.unstandardized_acceptance_method_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.AcceptanceMethod = &DelistAcceptanceMethod_UnstandardizedAcceptanceMethodType{x}
		return true, err
	case 2: // acceptance_method.method_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.AcceptanceMethod = &DelistAcceptanceMethod_MethodType{DelistAcceptanceMethodType(x)}
		return true, err
	default:
		return false, nil
	}
}

func _DelistAcceptanceMethod_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DelistAcceptanceMethod)
	// acceptance_method
	switch x := m.AcceptanceMethod.(type) {
	case *DelistAcceptanceMethod_UnstandardizedAcceptanceMethodType:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.UnstandardizedAcceptanceMethodType)))
		n += len(x.UnstandardizedAcceptanceMethodType)
	case *DelistAcceptanceMethod_MethodType:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.MethodType))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*GetNodeRequest)(nil), "abusemesh.GetNodeRequest")
	proto.RegisterType((*GetNodeTableRequest)(nil), "abusemesh.GetNodeTableRequest")
	proto.RegisterType((*GetNeighborTableRequest)(nil), "abusemesh.GetNeighborTableRequest")
	proto.RegisterType((*GetReportTableRequest)(nil), "abusemesh.GetReportTableRequest")
	proto.RegisterType((*GetDelistRequestTableRequest)(nil), "abusemesh.GetDelistRequestTableRequest")
	proto.RegisterType((*GetDelistAcceptanceTableRequest)(nil), "abusemesh.GetDelistAcceptanceTableRequest")
	proto.RegisterType((*TableUpdateStreamRequest)(nil), "abusemesh.TableUpdateStreamRequest")
	proto.RegisterType((*GetNodeTableResponse)(nil), "abusemesh.GetNodeTableResponse")
	proto.RegisterType((*GetNeighborTableResponse)(nil), "abusemesh.GetNeighborTableResponse")
	proto.RegisterType((*GetReportTableResponse)(nil), "abusemesh.GetReportTableResponse")
	proto.RegisterType((*GetDelistRequestTableResponse)(nil), "abusemesh.GetDelistRequestTableResponse")
	proto.RegisterType((*GetDelistAcceptanceTableResponse)(nil), "abusemesh.GetDelistAcceptanceTableResponse")
	proto.RegisterType((*TableUpdate)(nil), "abusemesh.TableUpdate")
	proto.RegisterType((*IPAddress)(nil), "abusemesh.IPAddress")
	proto.RegisterType((*IPRange)(nil), "abusemesh.IPRange")
	proto.RegisterType((*UUID)(nil), "abusemesh.UUID")
	proto.RegisterType((*Neighbor)(nil), "abusemesh.Neighbor")
	proto.RegisterType((*Node)(nil), "abusemesh.Node")
	proto.RegisterType((*ContactDetails)(nil), "abusemesh.ContactDetails")
	proto.RegisterType((*ContactDetails_Person)(nil), "abusemesh.ContactDetails.Person")
	proto.RegisterType((*PGPEntity)(nil), "abusemesh.PGPEntity")
	proto.RegisterType((*PGPIdentity)(nil), "abusemesh.PGPIdentity")
	proto.RegisterType((*PGPSignature)(nil), "abusemesh.PGPSignature")
	proto.RegisterType((*PGPSubkey)(nil), "abusemesh.PGPSubkey")
	proto.RegisterType((*Report)(nil), "abusemesh.Report")
	proto.RegisterType((*ReportConformation)(nil), "abusemesh.ReportConformation")
	proto.RegisterType((*AbuseDetectionMethod)(nil), "abusemesh.AbuseDetectionMethod")
	proto.RegisterType((*Evidence)(nil), "abusemesh.Evidence")
	proto.RegisterType((*DelistRequest)(nil), "abusemesh.DelistRequest")
	proto.RegisterType((*DelistAcceptance)(nil), "abusemesh.DelistAcceptance")
	proto.RegisterType((*DelistAcceptanceMethod)(nil), "abusemesh.DelistAcceptanceMethod")
	proto.RegisterEnum("abusemesh.TableUpdateType", TableUpdateType_name, TableUpdateType_value)
	proto.RegisterEnum("abusemesh.IPAddressFamily", IPAddressFamily_name, IPAddressFamily_value)
	proto.RegisterEnum("abusemesh.AbuseDetectionMethodType", AbuseDetectionMethodType_name, AbuseDetectionMethodType_value)
	proto.RegisterEnum("abusemesh.EvidenceType", EvidenceType_name, EvidenceType_value)
	proto.RegisterEnum("abusemesh.AbuseType", AbuseType_name, AbuseType_value)
	proto.RegisterEnum("abusemesh.DelistAcceptanceMethodType", DelistAcceptanceMethodType_name, DelistAcceptanceMethodType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AbuseMesh service

type AbuseMeshClient interface {
	// Returns the Node data of the current node
	GetNode(ctx context.Context, in *GetNodeRequest, opts ...grpc.CallOption) (*Node, error)
	// Returns the contents of the node table
	GetNodeTable(ctx context.Context, in *GetNodeTableRequest, opts ...grpc.CallOption) (*GetNodeTableResponse, error)
	// Returns the contents of the neighbor table of the node
	GetNeighborTable(ctx context.Context, in *GetNeighborTableRequest, opts ...grpc.CallOption) (*GetNeighborTableResponse, error)
	// Returns the contents of the report table of the node
	GetReportTable(ctx context.Context, in *GetReportTableRequest, opts ...grpc.CallOption) (*GetReportTableResponse, error)
	// Returns the contents of the report delist requests table of the node
	GetDelistRequestTable(ctx context.Context, in *GetDelistRequestTableRequest, opts ...grpc.CallOption) (*GetDelistRequestTableResponse, error)
	// Returns the contents of the report delist acceptance table of the node
	GetDelistAcceptanceTable(ctx context.Context, in *GetDelistAcceptanceTableRequest, opts ...grpc.CallOption) (*GetDelistAcceptanceTableResponse, error)
	// Opens a stream on which all updates to the tables of a node are published
	TableUpdateStream(ctx context.Context, in *TableUpdateStreamRequest, opts ...grpc.CallOption) (AbuseMesh_TableUpdateStreamClient, error)
}

type abuseMeshClient struct {
	cc *grpc.ClientConn
}

func NewAbuseMeshClient(cc *grpc.ClientConn) AbuseMeshClient {
	return &abuseMeshClient{cc}
}

func (c *abuseMeshClient) GetNode(ctx context.Context, in *GetNodeRequest, opts ...grpc.CallOption) (*Node, error) {
	out := new(Node)
	err := grpc.Invoke(ctx, "/abusemesh.AbuseMesh/GetNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *abuseMeshClient) GetNodeTable(ctx context.Context, in *GetNodeTableRequest, opts ...grpc.CallOption) (*GetNodeTableResponse, error) {
	out := new(GetNodeTableResponse)
	err := grpc.Invoke(ctx, "/abusemesh.AbuseMesh/GetNodeTable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *abuseMeshClient) GetNeighborTable(ctx context.Context, in *GetNeighborTableRequest, opts ...grpc.CallOption) (*GetNeighborTableResponse, error) {
	out := new(GetNeighborTableResponse)
	err := grpc.Invoke(ctx, "/abusemesh.AbuseMesh/GetNeighborTable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *abuseMeshClient) GetReportTable(ctx context.Context, in *GetReportTableRequest, opts ...grpc.CallOption) (*GetReportTableResponse, error) {
	out := new(GetReportTableResponse)
	err := grpc.Invoke(ctx, "/abusemesh.AbuseMesh/GetReportTable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *abuseMeshClient) GetDelistRequestTable(ctx context.Context, in *GetDelistRequestTableRequest, opts ...grpc.CallOption) (*GetDelistRequestTableResponse, error) {
	out := new(GetDelistRequestTableResponse)
	err := grpc.Invoke(ctx, "/abusemesh.AbuseMesh/GetDelistRequestTable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *abuseMeshClient) GetDelistAcceptanceTable(ctx context.Context, in *GetDelistAcceptanceTableRequest, opts ...grpc.CallOption) (*GetDelistAcceptanceTableResponse, error) {
	out := new(GetDelistAcceptanceTableResponse)
	err := grpc.Invoke(ctx, "/abusemesh.AbuseMesh/GetDelistAcceptanceTable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *abuseMeshClient) TableUpdateStream(ctx context.Context, in *TableUpdateStreamRequest, opts ...grpc.CallOption) (AbuseMesh_TableUpdateStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AbuseMesh_serviceDesc.Streams[0], c.cc, "/abusemesh.AbuseMesh/TableUpdateStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &abuseMeshTableUpdateStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AbuseMesh_TableUpdateStreamClient interface {
	Recv() (*TableUpdate, error)
	grpc.ClientStream
}

type abuseMeshTableUpdateStreamClient struct {
	grpc.ClientStream
}

func (x *abuseMeshTableUpdateStreamClient) Recv() (*TableUpdate, error) {
	m := new(TableUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AbuseMesh service

type AbuseMeshServer interface {
	// Returns the Node data of the current node
	GetNode(context.Context, *GetNodeRequest) (*Node, error)
	// Returns the contents of the node table
	GetNodeTable(context.Context, *GetNodeTableRequest) (*GetNodeTableResponse, error)
	// Returns the contents of the neighbor table of the node
	GetNeighborTable(context.Context, *GetNeighborTableRequest) (*GetNeighborTableResponse, error)
	// Returns the contents of the report table of the node
	GetReportTable(context.Context, *GetReportTableRequest) (*GetReportTableResponse, error)
	// Returns the contents of the report delist requests table of the node
	GetDelistRequestTable(context.Context, *GetDelistRequestTableRequest) (*GetDelistRequestTableResponse, error)
	// Returns the contents of the report delist acceptance table of the node
	GetDelistAcceptanceTable(context.Context, *GetDelistAcceptanceTableRequest) (*GetDelistAcceptanceTableResponse, error)
	// Opens a stream on which all updates to the tables of a node are published
	TableUpdateStream(*TableUpdateStreamRequest, AbuseMesh_TableUpdateStreamServer) error
}

func RegisterAbuseMeshServer(s *grpc.Server, srv AbuseMeshServer) {
	s.RegisterService(&_AbuseMesh_serviceDesc, srv)
}

func _AbuseMesh_GetNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AbuseMeshServer).GetNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/abusemesh.AbuseMesh/GetNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AbuseMeshServer).GetNode(ctx, req.(*GetNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AbuseMesh_GetNodeTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AbuseMeshServer).GetNodeTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/abusemesh.AbuseMesh/GetNodeTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AbuseMeshServer).GetNodeTable(ctx, req.(*GetNodeTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AbuseMesh_GetNeighborTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNeighborTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AbuseMeshServer).GetNeighborTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/abusemesh.AbuseMesh/GetNeighborTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AbuseMeshServer).GetNeighborTable(ctx, req.(*GetNeighborTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AbuseMesh_GetReportTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReportTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AbuseMeshServer).GetReportTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/abusemesh.AbuseMesh/GetReportTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AbuseMeshServer).GetReportTable(ctx, req.(*GetReportTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AbuseMesh_GetDelistRequestTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDelistRequestTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AbuseMeshServer).GetDelistRequestTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/abusemesh.AbuseMesh/GetDelistRequestTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AbuseMeshServer).GetDelistRequestTable(ctx, req.(*GetDelistRequestTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AbuseMesh_GetDelistAcceptanceTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDelistAcceptanceTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AbuseMeshServer).GetDelistAcceptanceTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/abusemesh.AbuseMesh/GetDelistAcceptanceTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AbuseMeshServer).GetDelistAcceptanceTable(ctx, req.(*GetDelistAcceptanceTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AbuseMesh_TableUpdateStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TableUpdateStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AbuseMeshServer).TableUpdateStream(m, &abuseMeshTableUpdateStreamServer{stream})
}

type AbuseMesh_TableUpdateStreamServer interface {
	Send(*TableUpdate) error
	grpc.ServerStream
}

type abuseMeshTableUpdateStreamServer struct {
	grpc.ServerStream
}

func (x *abuseMeshTableUpdateStreamServer) Send(m *TableUpdate) error {
	return x.ServerStream.SendMsg(m)
}

var _AbuseMesh_serviceDesc = grpc.ServiceDesc{
	ServiceName: "abusemesh.AbuseMesh",
	HandlerType: (*AbuseMeshServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNode",
			Handler:    _AbuseMesh_GetNode_Handler,
		},
		{
			MethodName: "GetNodeTable",
			Handler:    _AbuseMesh_GetNodeTable_Handler,
		},
		{
			MethodName: "GetNeighborTable",
			Handler:    _AbuseMesh_GetNeighborTable_Handler,
		},
		{
			MethodName: "GetReportTable",
			Handler:    _AbuseMesh_GetReportTable_Handler,
		},
		{
			MethodName: "GetDelistRequestTable",
			Handler:    _AbuseMesh_GetDelistRequestTable_Handler,
		},
		{
			MethodName: "GetDelistAcceptanceTable",
			Handler:    _AbuseMesh_GetDelistAcceptanceTable_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TableUpdateStream",
			Handler:       _AbuseMesh_TableUpdateStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "abuse-mesh.proto",
}

func init() { proto.RegisterFile("abuse-mesh.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2161 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0x4b, 0x73, 0xdb, 0xc8,
	0x11, 0x26, 0xf4, 0xa0, 0xc8, 0x26, 0x45, 0x41, 0x23, 0x5b, 0xa2, 0xb9, 0xf2, 0x4a, 0x82, 0xcb,
	0xbb, 0xb6, 0x9c, 0xd5, 0xc6, 0xde, 0xd8, 0x9b, 0xd8, 0x49, 0xaa, 0xf8, 0x80, 0x45, 0xd8, 0x14,
	0xc5, 0x80, 0xa4, 0x37, 0xae, 0x1c, 0x50, 0x20, 0x31, 0x92, 0xe0, 0x25, 0x09, 0x04, 0x00, 0x9d,
	0x30, 0x7f, 0x21, 0xb7, 0x9c, 0x53, 0x95, 0x1f, 0x91, 0x53, 0x2e, 0xf9, 0x01, 0xa9, 0x54, 0xe5,
	0x90, 0x9f, 0x91, 0xdb, 0x9e, 0x73, 0x48, 0xcd, 0x03, 0x20, 0x5e, 0xa4, 0xb4, 0xae, 0xb8, 0x92,
	0x1b, 0xa6, 0xfb, 0xeb, 0x6f, 0x66, 0xfa, 0x31, 0x0d, 0x60, 0x40, 0xd4, 0x07, 0x53, 0x17, 0x7f,
	0x31, 0xc6, 0xee, 0xd5, 0x89, 0xed, 0x58, 0x9e, 0x85, 0xf2, 0x54, 0x42, 0x04, 0x92, 0x08, 0xa5,
	0x53, 0xec, 0xb5, 0x2d, 0x03, 0xab, 0xf8, 0xd7, 0x53, 0xec, 0x7a, 0xd2, 0x6d, 0xd8, 0xe1, 0x92,
	0x9e, 0x3e, 0x18, 0x05, 0xe2, 0xc7, 0xb0, 0x47, 0xc4, 0xd8, 0xbc, 0xbc, 0x1a, 0x58, 0x4e, 0x58,
	0x85, 0x76, 0x21, 0x7b, 0x39, 0xb2, 0x06, 0xfa, 0xa8, 0x2c, 0x1c, 0x0a, 0x0f, 0x72, 0x2a, 0x1f,
	0x49, 0x7b, 0x70, 0xfb, 0x14, 0x7b, 0x2a, 0xb6, 0x2d, 0xc7, 0x8b, 0x70, 0x7d, 0x0a, 0xfb, 0xa7,
	0xd8, 0x6b, 0xe0, 0x91, 0xe9, 0x7a, 0x5c, 0x16, 0xd1, 0x1f, 0xc1, 0x41, 0xa0, 0xaf, 0x0e, 0x87,
	0xd8, 0xf6, 0xf4, 0xc9, 0x30, 0xba, 0x9c, 0x0a, 0x94, 0xe9, 0xb8, 0x6f, 0x1b, 0xba, 0x87, 0xbb,
	0x9e, 0x83, 0xf5, 0xb1, 0xaf, 0xfb, 0x19, 0xdc, 0x8a, 0xee, 0xc0, 0xb5, 0xad, 0x89, 0x8b, 0xd1,
	0x7d, 0x58, 0x9f, 0x58, 0x06, 0x76, 0xcb, 0xc2, 0xe1, 0xea, 0x83, 0xc2, 0x93, 0xad, 0x93, 0xc0,
	0x0d, 0x27, 0xd4, 0x01, 0x4c, 0x2b, 0x9d, 0x41, 0x39, 0xb9, 0x53, 0x4e, 0xf1, 0x18, 0xf2, 0x13,
	0xae, 0xf0, 0x69, 0x76, 0xc2, 0x34, 0x5c, 0xa7, 0xce, 0x51, 0x92, 0x0c, 0xbb, 0x71, 0x2f, 0x70,
	0xb2, 0x47, 0xb0, 0xe1, 0x50, 0xb1, 0x4f, 0xb5, 0x1d, 0xa2, 0x62, 0x06, 0xaa, 0x8f, 0x90, 0x06,
	0x70, 0x77, 0x81, 0xcf, 0x38, 0x5b, 0x15, 0xb6, 0x0c, 0xaa, 0xd5, 0x1c, 0xa6, 0xf6, 0x59, 0xcb,
	0x21, 0xd6, 0x88, 0xbd, 0x5a, 0x32, 0xc2, 0x43, 0x57, 0x1a, 0xc1, 0xe1, 0x62, 0xbf, 0xf3, 0x69,
	0x9a, 0xb0, 0xcd, 0xa7, 0xd1, 0x03, 0x04, 0x9f, 0xe8, 0x93, 0xc4, 0x44, 0x73, 0x12, 0x55, 0x34,
	0x62, 0x12, 0xe9, 0xbb, 0x15, 0x28, 0x84, 0x62, 0x88, 0x5e, 0x40, 0x61, 0x4a, 0x9f, 0x34, 0x6f,
	0x66, 0x63, 0x9a, 0x4b, 0xa5, 0x27, 0x95, 0x10, 0x67, 0x08, 0xdc, 0x9b, 0xd9, 0x58, 0x85, 0x69,
	0xf0, 0x8c, 0xee, 0xc3, 0x1a, 0x89, 0x5e, 0x79, 0xe5, 0x50, 0x48, 0x09, 0x6d, 0x33, 0xa3, 0x52,
	0x35, 0x7a, 0x0c, 0x39, 0x3f, 0x32, 0xe5, 0x55, 0x0a, 0x4d, 0x0b, 0x5f, 0x33, 0xa3, 0x06, 0x30,
	0xf4, 0x08, 0xb2, 0x2c, 0x06, 0xe5, 0x35, 0x6a, 0x90, 0x0c, 0x52, 0x33, 0xa3, 0x72, 0x08, 0xaa,
	0x27, 0x83, 0xb0, 0x4e, 0xad, 0x16, 0x06, 0xa1, 0x99, 0x89, 0x87, 0x01, 0xbd, 0x4a, 0x73, 0x71,
	0x96, 0xd2, 0x2c, 0x73, 0x71, 0x33, 0x93, 0x74, 0x72, 0xad, 0x04, 0x45, 0x8f, 0xb8, 0x4d, 0xc3,
	0x13, 0xcf, 0xf4, 0x66, 0xd2, 0x15, 0xe4, 0x95, 0x4e, 0xd5, 0x30, 0x1c, 0xec, 0xba, 0xa8, 0x0a,
	0x25, 0x9d, 0x3d, 0x6a, 0x17, 0xfa, 0xd8, 0x1c, 0xcd, 0x52, 0x9c, 0x1e, 0xa0, 0x5f, 0x52, 0x84,
	0xba, 0xa9, 0x87, 0x87, 0xa8, 0x0c, 0x1b, 0x5c, 0x40, 0x5d, 0x9f, 0x57, 0xfd, 0xa1, 0xf4, 0x0b,
	0xd8, 0x50, 0x3a, 0xaa, 0x3e, 0xb9, 0xc4, 0xe8, 0x64, 0x0e, 0x12, 0xe8, 0x36, 0x6e, 0xa5, 0x4d,
	0x10, 0x98, 0x92, 0x03, 0xc5, 0x76, 0xf0, 0x85, 0xf9, 0x5b, 0xca, 0xb9, 0xae, 0xf2, 0x91, 0x54,
	0x81, 0xb5, 0x7e, 0x5f, 0x69, 0x20, 0x04, 0x6b, 0xd3, 0xa9, 0x69, 0x50, 0xb2, 0xbc, 0x4a, 0x9f,
	0xa5, 0x2f, 0x21, 0xe7, 0x87, 0x0f, 0xdd, 0xe3, 0xc9, 0x20, 0xa4, 0x26, 0x03, 0x4b, 0x05, 0xe9,
	0x5f, 0x02, 0xac, 0x91, 0x21, 0x41, 0x07, 0x6c, 0x51, 0x34, 0x99, 0x8c, 0xd1, 0xa3, 0xaf, 0x00,
	0x4c, 0x5b, 0x0b, 0x6f, 0x75, 0xd1, 0x2e, 0xf2, 0xa6, 0xed, 0xfb, 0xb7, 0x06, 0x5b, 0x43, 0x6b,
	0xe2, 0xe9, 0x43, 0x4f, 0x33, 0xb0, 0xa7, 0x9b, 0x23, 0x97, 0x27, 0xdd, 0x9d, 0x90, 0x65, 0x9d,
	0x21, 0x1a, 0x0c, 0xa0, 0x96, 0x86, 0x91, 0x31, 0x12, 0x61, 0xb5, 0xda, 0x6d, 0xd3, 0xdc, 0x5b,
	0x57, 0xc9, 0x23, 0x59, 0x8a, 0x7d, 0x69, 0xf3, 0x80, 0xf2, 0xf4, 0x0a, 0x2f, 0xa5, 0x73, 0xda,
	0x91, 0xa9, 0x4e, 0xcd, 0xdb, 0x97, 0x36, 0x7b, 0x94, 0xfe, 0xba, 0x0a, 0xa5, 0xe8, 0x4c, 0xe8,
	0x08, 0x8a, 0x43, 0x6b, 0x6c, 0xeb, 0x93, 0x99, 0x36, 0xd1, 0xc7, 0x98, 0x7b, 0xb3, 0xc0, 0x65,
	0x6d, 0x7d, 0x4c, 0x5c, 0xb3, 0x89, 0xc7, 0xba, 0x39, 0xd2, 0xa2, 0x31, 0x2e, 0x52, 0xa1, 0xbf,
	0xcb, 0x23, 0x28, 0xda, 0x57, 0xd6, 0x04, 0x6b, 0x93, 0xe9, 0x78, 0x80, 0x59, 0x5d, 0xe5, 0xd5,
	0x02, 0x95, 0xb5, 0xa9, 0x08, 0x3d, 0x04, 0xd1, 0xbe, 0x9a, 0xb9, 0xe6, 0x50, 0x9f, 0x53, 0xad,
	0x51, 0xd8, 0x96, 0x2f, 0xf7, 0xd9, 0x94, 0xb9, 0xcf, 0x6c, 0xec, 0xb8, 0xd6, 0x84, 0x54, 0x10,
	0x39, 0x5d, 0x0e, 0x17, 0xfa, 0xec, 0xa4, 0x43, 0x81, 0x81, 0xeb, 0xd8, 0xd0, 0xad, 0xfc, 0x4d,
	0x80, 0x2c, 0x7b, 0x46, 0x77, 0x01, 0x2e, 0x4c, 0xc7, 0xf5, 0xd8, 0x4e, 0xb3, 0x74, 0xea, 0x3c,
	0x95, 0xd0, 0x7d, 0x1e, 0x40, 0x61, 0x6c, 0x1a, 0xc6, 0x08, 0x33, 0xfd, 0x06, 0xd5, 0x03, 0x13,
	0x51, 0xc0, 0x27, 0x90, 0x1f, 0xe9, 0xbe, 0x79, 0x8e, 0xaa, 0x73, 0x44, 0xe0, 0x2b, 0xdf, 0x59,
	0x03, 0xcd, 0x33, 0xbd, 0x11, 0x2e, 0xe7, 0x99, 0xf2, 0x9d, 0x35, 0xe8, 0x91, 0x71, 0xd2, 0x85,
	0x70, 0x03, 0x17, 0x16, 0x12, 0x2e, 0x94, 0xfe, 0x20, 0x40, 0x3e, 0x88, 0x2c, 0xd9, 0x8f, 0x3d,
	0x1d, 0x8c, 0xcc, 0xa1, 0xf6, 0x2d, 0x9e, 0xf1, 0xc8, 0xe5, 0x99, 0xe4, 0x35, 0x9e, 0xa1, 0x67,
	0x00, 0xa6, 0x41, 0x13, 0xc4, 0xc4, 0x24, 0x68, 0xc4, 0x7f, 0xbb, 0xd1, 0x14, 0x51, 0x98, 0x7e,
	0xa6, 0x86, 0x90, 0xa4, 0x50, 0xdd, 0xe9, 0xe0, 0x5b, 0x3c, 0x23, 0x89, 0xba, 0x9a, 0xcc, 0xab,
	0x2e, 0x55, 0xaa, 0x3e, 0x48, 0xfa, 0x93, 0x00, 0x85, 0x10, 0x17, 0xda, 0x83, 0x8d, 0xa9, 0x8b,
	0x1d, 0x2d, 0xa8, 0xcd, 0x2c, 0x19, 0x2a, 0x06, 0xfa, 0x39, 0x94, 0x5c, 0x3c, 0xba, 0xd0, 0x5c,
	0xf3, 0x72, 0xa2, 0x7b, 0x53, 0xc7, 0x3f, 0xa8, 0xf7, 0x62, 0xfc, 0xbe, 0x5a, 0xdd, 0x24, 0xf0,
	0x60, 0x88, 0xbe, 0x06, 0x08, 0x4c, 0xfd, 0xb5, 0x2d, 0xb4, 0x0d, 0x41, 0xa5, 0x1f, 0x40, 0x31,
	0xac, 0x43, 0xfb, 0x90, 0x9f, 0xaf, 0x81, 0xfb, 0x2d, 0x10, 0x48, 0x3a, 0xf5, 0x31, 0xdb, 0xe5,
	0x75, 0x3e, 0x7e, 0x1a, 0x66, 0xba, 0x66, 0x37, 0xa1, 0x29, 0xfe, 0x99, 0x83, 0x2c, 0x6b, 0x1b,
	0x37, 0x3b, 0x78, 0x1e, 0x41, 0x8e, 0xf5, 0x16, 0xec, 0xa4, 0x34, 0x37, 0x0a, 0x0c, 0x00, 0xe8,
	0x21, 0x89, 0x9f, 0x6b, 0xe3, 0xa1, 0xc7, 0x0f, 0x9a, 0x04, 0xd6, 0xd7, 0x47, 0x97, 0xbf, 0x76,
	0xd3, 0xe5, 0xa3, 0x9f, 0xc2, 0x9d, 0xe9, 0xc4, 0xf5, 0xf4, 0x89, 0xa1, 0x3b, 0x86, 0xf9, 0x3b,
	0x6c, 0x68, 0xd4, 0x86, 0xb5, 0x6c, 0x72, 0x16, 0xe5, 0x9b, 0x19, 0x75, 0x2f, 0x0a, 0xa9, 0x12,
	0x04, 0xed, 0xd2, 0x4f, 0x01, 0x42, 0xf0, 0x2c, 0x6d, 0x36, 0xe1, 0x14, 0x0b, 0x90, 0xcd, 0x8c,
	0xca, 0x5e, 0x52, 0xa9, 0xd9, 0x21, 0x14, 0x0c, 0xec, 0x0e, 0x1d, 0xd3, 0xf6, 0x4c, 0x6b, 0xc2,
	0xcb, 0x33, 0x2c, 0x42, 0xbb, 0xb0, 0x4e, 0x0b, 0x8a, 0xd5, 0x66, 0x53, 0x50, 0xd9, 0x10, 0x1d,
	0x41, 0xc1, 0xb0, 0xc6, 0xba, 0x39, 0x61, 0x95, 0x9b, 0xe7, 0x5a, 0x60, 0x42, 0x5a, 0xbd, 0x08,
	0x56, 0xa7, 0xce, 0x88, 0x95, 0x65, 0x53, 0x50, 0xc9, 0x00, 0x7d, 0x06, 0x2b, 0xa6, 0x4d, 0xab,
	0x70, 0xc1, 0x29, 0xdf, 0x14, 0xd4, 0x15, 0xd3, 0x46, 0x5f, 0x42, 0xce, 0xb4, 0x35, 0x87, 0x34,
	0xb9, 0x72, 0x91, 0xa2, 0x51, 0x04, 0x4d, 0xdb, 0x5f, 0x53, 0x50, 0x37, 0x4c, 0x9b, 0x75, 0xc2,
	0x17, 0x90, 0xc3, 0xef, 0x49, 0xc1, 0x0d, 0x71, 0x79, 0x93, 0x66, 0xf1, 0x41, 0xe2, 0x75, 0xe2,
	0x44, 0xe6, 0x08, 0x79, 0xe2, 0x39, 0x33, 0x35, 0x30, 0x40, 0xbf, 0x84, 0x9d, 0xb9, 0xf7, 0xb4,
	0x31, 0xf6, 0x74, 0x43, 0xf7, 0xf4, 0x72, 0x89, 0xf2, 0x3c, 0x48, 0xf2, 0x04, 0xde, 0x3c, 0xe3,
	0x50, 0x46, 0xb8, 0xad, 0xc7, 0xe5, 0xe8, 0x15, 0x88, 0x06, 0xf6, 0xf0, 0x90, 0xf8, 0x92, 0x10,
	0x5f, 0x59, 0x46, 0x79, 0x8b, 0xee, 0xe7, 0x20, 0x1e, 0x9d, 0x86, 0x8f, 0x3b, 0xa3, 0x30, 0x75,
	0xcb, 0x88, 0x0a, 0xd0, 0x3b, 0xb8, 0x13, 0xe7, 0x9a, 0xaf, 0x55, 0xa4, 0x6b, 0x3d, 0x49, 0xae,
	0x35, 0x46, 0x1b, 0x5d, 0xf1, 0x9e, 0x91, 0xae, 0xad, 0x74, 0x60, 0x33, 0xe2, 0x2c, 0xd2, 0x2d,
	0xe7, 0xc5, 0x4a, 0x1e, 0xd1, 0x43, 0x58, 0x7f, 0xaf, 0x8f, 0xa6, 0x7e, 0x89, 0x86, 0x5f, 0xf7,
	0x7c, 0x53, 0x95, 0x21, 0x9e, 0xaf, 0xfc, 0x58, 0xa8, 0x34, 0x60, 0x37, 0xdd, 0x6d, 0x29, 0xd4,
	0xb7, 0xc2, 0xd4, 0xf9, 0x30, 0xcb, 0x2b, 0xd8, 0x5f, 0xb6, 0xa1, 0xef, 0xc3, 0x55, 0xdb, 0x81,
	0x6d, 0x56, 0xdf, 0xa1, 0x4a, 0x23, 0xaf, 0x75, 0x6c, 0x64, 0x39, 0xe6, 0xa5, 0x39, 0x91, 0x7e,
	0xbf, 0x0e, 0x88, 0x79, 0xb2, 0x6e, 0x4d, 0x2e, 0x2c, 0x67, 0xac, 0xd3, 0xb2, 0xb8, 0xd1, 0x09,
	0x73, 0x6f, 0xe1, 0xab, 0x33, 0x03, 0xd1, 0x17, 0xe7, 0xcf, 0x83, 0xb7, 0xe0, 0x05, 0x07, 0x8b,
	0xff, 0x06, 0xfc, 0x81, 0xe7, 0x4a, 0xac, 0xc4, 0xd7, 0x93, 0x25, 0x7e, 0x1a, 0x2a, 0x9d, 0x2c,
	0x4d, 0xa3, 0x47, 0x89, 0x34, 0x0a, 0x6f, 0x7e, 0x61, 0x19, 0xa5, 0x25, 0xfb, 0xc6, 0x07, 0x26,
	0xfb, 0xfb, 0x65, 0xc9, 0x9e, 0xa3, 0xab, 0x7c, 0xbe, 0x7c, 0x95, 0xff, 0x2f, 0x89, 0xff, 0x5f,
	0x4c, 0x59, 0xe9, 0x1f, 0x02, 0xdc, 0x4a, 0xf3, 0x1f, 0x6a, 0xc2, 0x41, 0xac, 0x7b, 0x24, 0x22,
	0x21, 0xf0, 0x1e, 0x72, 0x37, 0x0a, 0x8c, 0x33, 0xbd, 0x85, 0xdb, 0x09, 0xc7, 0xd3, 0xa6, 0xb2,
	0x42, 0x9b, 0xca, 0xbd, 0x6b, 0x22, 0xc9, 0x7b, 0xcc, 0x8e, 0x91, 0x14, 0xd7, 0x50, 0x32, 0x3f,
	0xa4, 0x3f, 0x0b, 0x90, 0xf3, 0xbd, 0x86, 0x6a, 0xb0, 0x1f, 0xdb, 0x85, 0x9f, 0x5b, 0xf3, 0x2f,
	0x57, 0xb2, 0x85, 0x4a, 0x14, 0xe5, 0xdb, 0xd3, 0x96, 0xf6, 0x05, 0xac, 0x85, 0x96, 0xbb, 0x97,
	0x12, 0x1c, 0xbe, 0x44, 0x0a, 0xa3, 0x6f, 0x91, 0xfe, 0x1c, 0x34, 0xb7, 0x48, 0x15, 0x16, 0xd5,
	0xa2, 0x2f, 0x6c, 0xe8, 0x9e, 0x5e, 0xdb, 0x0a, 0x81, 0x88, 0x95, 0xf4, 0xdd, 0x2a, 0x6c, 0x46,
	0x3e, 0x36, 0x6f, 0x76, 0x20, 0xcc, 0x6b, 0x7d, 0x65, 0x79, 0xad, 0xfb, 0x27, 0xc7, 0xea, 0x92,
	0xef, 0xac, 0x8f, 0x77, 0x20, 0xd4, 0x12, 0x07, 0xc2, 0x67, 0x8b, 0x3e, 0xb2, 0x17, 0x9e, 0x05,
	0x35, 0xc8, 0x05, 0xe5, 0xba, 0x71, 0x0d, 0x47, 0xb4, 0x34, 0x03, 0xbb, 0x8f, 0x50, 0x8b, 0x2f,
	0x60, 0xf3, 0xc3, 0x8b, 0xef, 0x8f, 0xeb, 0x20, 0xc6, 0x7f, 0x0d, 0xdc, 0x2c, 0xee, 0xcf, 0xa0,
	0x14, 0xfd, 0x79, 0xb1, 0x28, 0xfe, 0x9b, 0x46, 0x3c, 0xa9, 0xfe, 0x87, 0x69, 0x20, 0x27, 0xd2,
	0xe0, 0xe1, 0x92, 0x9f, 0x24, 0x0b, 0x33, 0xa1, 0x0d, 0xdb, 0xf3, 0xbf, 0x2d, 0xd1, 0xb6, 0x70,
	0xb4, 0x84, 0x8f, 0x37, 0x06, 0x51, 0x8f, 0x49, 0xd0, 0x6f, 0xa0, 0x92, 0xe0, 0x8b, 0xb7, 0x86,
	0x9f, 0x2c, 0x5b, 0x68, 0x7c, 0x8e, 0x68, 0xfa, 0x95, 0xf5, 0x05, 0xea, 0x8f, 0x90, 0x8e, 0xaf,
	0xe1, 0xee, 0xd2, 0xc5, 0x7c, 0xaf, 0xf4, 0xfc, 0xbb, 0x00, 0xbb, 0xe9, 0x4e, 0x44, 0x5d, 0xb8,
	0x1f, 0xff, 0xb6, 0x48, 0x78, 0x30, 0x72, 0xc0, 0x4a, 0xb1, 0xef, 0x8c, 0x18, 0x21, 0x3d, 0x68,
	0x9b, 0x50, 0x48, 0xb6, 0x87, 0xfb, 0xd7, 0x46, 0x94, 0x9f, 0xbe, 0x30, 0x9e, 0xf7, 0x85, 0x9d,
	0x94, 0x0c, 0x39, 0xfe, 0x06, 0xb6, 0x62, 0xbf, 0x25, 0xd1, 0x2d, 0x10, 0x7b, 0xd5, 0x5a, 0x4b,
	0xd6, 0xfa, 0x9d, 0x46, 0xb5, 0x27, 0x6b, 0x6d, 0xf9, 0x1b, 0x31, 0x83, 0x6e, 0xc3, 0x76, 0x44,
	0x2a, 0x37, 0x94, 0x9e, 0x28, 0xa0, 0x3d, 0xd8, 0x89, 0x88, 0x1b, 0x72, 0x4b, 0xee, 0xc9, 0xe2,
	0xca, 0xf1, 0xd7, 0xb0, 0x15, 0xfb, 0xf5, 0x86, 0xb6, 0x61, 0x53, 0xe9, 0xbc, 0xac, 0x9e, 0x29,
	0xad, 0xb7, 0x9a, 0xd2, 0x79, 0xf3, 0x23, 0x31, 0x13, 0x17, 0x3d, 0x13, 0x85, 0xe3, 0x67, 0x50,
	0x5e, 0xd4, 0xf1, 0x50, 0x05, 0x76, 0xab, 0xb5, 0x7e, 0x97, 0x4c, 0xd3, 0x93, 0xeb, 0x3d, 0xe5,
	0xbc, 0xad, 0x9d, 0x55, 0xdb, 0xfd, 0x6a, 0x4b, 0xcc, 0x1c, 0xbf, 0x85, 0x62, 0xa4, 0x43, 0x89,
	0x50, 0x94, 0xdf, 0x28, 0x0d, 0xb9, 0x5d, 0x97, 0xb5, 0xbe, 0xda, 0x12, 0x33, 0x11, 0x49, 0xeb,
	0xfc, 0x54, 0x14, 0x10, 0x82, 0x52, 0x20, 0x51, 0xce, 0xaa, 0xa7, 0xb2, 0xb8, 0x42, 0x96, 0x14,
	0xc8, 0x3a, 0xf5, 0x6a, 0x47, 0x5c, 0x3d, 0xfe, 0x8b, 0x00, 0xf9, 0xf9, 0x47, 0x60, 0x09, 0x80,
	0x2d, 0xa2, 0xdb, 0xa9, 0x9e, 0x89, 0x19, 0x42, 0xc2, 0xc6, 0x9d, 0xa6, 0xd2, 0x6d, 0x2a, 0x6d,
	0x42, 0xbc, 0x09, 0x79, 0xbe, 0xd0, 0xf3, 0xae, 0xb8, 0x82, 0x0e, 0x61, 0x9f, 0x0d, 0xeb, 0xe7,
	0x9d, 0xb7, 0xaa, 0x72, 0xda, 0xec, 0x69, 0x4a, 0xfb, 0xa5, 0xaa, 0xb4, 0x4f, 0xe5, 0x33, 0xb9,
	0xdd, 0x13, 0x57, 0xd1, 0x1d, 0xb8, 0xcd, 0x10, 0x4a, 0xab, 0x25, 0x9f, 0x56, 0x5b, 0x5a, 0xfd,
	0xbc, 0xdd, 0x23, 0xaa, 0x35, 0xf4, 0x29, 0x54, 0x98, 0xaa, 0xdf, 0xee, 0x56, 0xdb, 0x74, 0xd7,
	0x72, 0x43, 0x6b, 0x56, 0xeb, 0xaf, 0xc9, 0x5c, 0xeb, 0x68, 0x1f, 0xca, 0x4c, 0xff, 0x46, 0x51,
	0xfb, 0x5d, 0xad, 0xa1, 0x74, 0x7b, 0xaa, 0x52, 0xeb, 0x13, 0x9c, 0x98, 0x3d, 0x7e, 0x0e, 0x95,
	0xc5, 0x19, 0x42, 0x6c, 0x1b, 0x72, 0x4b, 0xe9, 0xf6, 0xb4, 0x6a, 0xbd, 0x2e, 0x77, 0x7a, 0x55,
	0xb2, 0x6b, 0xdf, 0xa5, 0x4f, 0xfe, 0xbd, 0xc6, 0xf7, 0x7d, 0x86, 0xdd, 0x2b, 0xf4, 0x14, 0x36,
	0xf8, 0xb5, 0x04, 0x0a, 0xff, 0xff, 0x8b, 0x5e, 0xbf, 0x54, 0xe2, 0xc7, 0x27, 0x3a, 0x87, 0x62,
	0xf8, 0x36, 0x03, 0x7d, 0x9a, 0xb4, 0x0d, 0xdf, 0x8c, 0x54, 0x0e, 0x16, 0xea, 0xf9, 0x1f, 0xfc,
	0x5f, 0x81, 0x18, 0xbf, 0xdf, 0x40, 0x52, 0xcc, 0x28, 0xe5, 0x9a, 0xa7, 0x72, 0x6f, 0x29, 0x86,
	0x93, 0xf7, 0xe9, 0x7d, 0x52, 0xe8, 0xb6, 0x03, 0x1d, 0x46, 0xcd, 0x92, 0xd7, 0x41, 0x95, 0xa3,
	0x25, 0x08, 0x4e, 0xfb, 0x8e, 0x5e, 0x25, 0x25, 0x6f, 0x3f, 0xd0, 0xe7, 0x51, 0xdb, 0x85, 0x77,
	0x4a, 0x95, 0x07, 0xd7, 0x03, 0xf9, 0x5c, 0x2e, 0xbd, 0xff, 0x49, 0xbd, 0x05, 0x41, 0xc7, 0x69,
	0x2c, 0xe9, 0x57, 0x54, 0x95, 0x47, 0x37, 0xc2, 0xf2, 0x49, 0x55, 0xd8, 0x4e, 0xdc, 0x67, 0xa1,
	0x7b, 0xe9, 0x97, 0x1f, 0x91, 0xdb, 0xae, 0xca, 0x6e, 0x3a, 0xe8, 0x87, 0xc2, 0x20, 0x4b, 0x6f,
	0xfb, 0xbe, 0xfa, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x1d, 0x88, 0xd2, 0xa8, 0x01, 0x1c, 0x00,
	0x00,
}
