// Code generated by protoc-gen-go. DO NOT EDIT.
// source: abuse-mesh-common.proto

/*
Package abusemesh is a generated protocol buffer package.

It is generated from these files:
	abuse-mesh-common.proto
	abuse-mesh.proto

It has these top-level messages:
	IPAddress
	IPRange
	UUID
	Neighbor
	Node
	ContactDetails
	PGPEntity
	PGPSignature
	Report
	ReportConfirmation
	AbuseDetectionMethod
	Evidence
	DelistRequest
	DelistAcceptance
	DelistAcceptanceMethod
	GetNodeRequest
	OfferSignatureRequest
	GetNodeTableRequest
	GetNeighborTableRequest
	GetReportTableRequest
	GetReportConfirmationTableRequest
	GetDelistRequestTableRequest
	GetDelistAcceptanceTableRequest
	TableEventStreamRequest
	GetHistoricTableEventsRequest
	GetNodeTableResponse
	OfferSignatureResponse
	GetNeighborTableResponse
	GetReportTableResponse
	GetReportConfirmationTableResponse
	GetDelistRequestTableResponse
	GetDelistAcceptanceTableResponse
	GetHistoricTableEventsResponse
	TableEvent
*/
package abusemesh

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type IPAddressFamily int32

const (
	IPAddressFamily_IPFAMILY_IPV4 IPAddressFamily = 0
	IPAddressFamily_IPFAMILY_IPV6 IPAddressFamily = 1
)

var IPAddressFamily_name = map[int32]string{
	0: "IPFAMILY_IPV4",
	1: "IPFAMILY_IPV6",
}
var IPAddressFamily_value = map[string]int32{
	"IPFAMILY_IPV4": 0,
	"IPFAMILY_IPV6": 1,
}

func (x IPAddressFamily) String() string {
	return proto.EnumName(IPAddressFamily_name, int32(x))
}
func (IPAddressFamily) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type AbuseDetectionMethodType int32

const (
	// TODO add standardized detection method types
	AbuseDetectionMethodType_ABUSE_DETECTION_MANUAL AbuseDetectionMethodType = 0
)

var AbuseDetectionMethodType_name = map[int32]string{
	0: "ABUSE_DETECTION_MANUAL",
}
var AbuseDetectionMethodType_value = map[string]int32{
	"ABUSE_DETECTION_MANUAL": 0,
}

func (x AbuseDetectionMethodType) String() string {
	return proto.EnumName(AbuseDetectionMethodType_name, int32(x))
}
func (AbuseDetectionMethodType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type EvidenceType int32

const (
	// TODO add all evidence types
	EvidenceType_EVIDENCE_URL   EvidenceType = 0
	EvidenceType_EVIDENCE_LOG   EvidenceType = 1
	EvidenceType_EVIDENCE_IMAGE EvidenceType = 2
	EvidenceType_EVIDENCE_PCAP  EvidenceType = 3
)

var EvidenceType_name = map[int32]string{
	0: "EVIDENCE_URL",
	1: "EVIDENCE_LOG",
	2: "EVIDENCE_IMAGE",
	3: "EVIDENCE_PCAP",
}
var EvidenceType_value = map[string]int32{
	"EVIDENCE_URL":   0,
	"EVIDENCE_LOG":   1,
	"EVIDENCE_IMAGE": 2,
	"EVIDENCE_PCAP":  3,
}

func (x EvidenceType) String() string {
	return proto.EnumName(EvidenceType_name, int32(x))
}
func (EvidenceType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// NOTE: This list is not complete and probably never will be
// This list must be moderated with the following guidelines:
// 1. General categories, details and variations can be managed with metadata. This keeps the list stable
// 2. Only generally considered abuse, this list should contain acts which are almost unanimously labeled abuse.
//    Very disputable acts like port scanning(at the time of writing this) should be be part of the standard until
//    a great majority of the the community labels it as abuse.
//    However just because one or a few geo political entities allow a act doesn't mean it is not belong on this list
type AbuseType int32

const (
	// A abuse report of spam
	AbuseType_ABUSE_SPAM AbuseType = 0
	// A abuse report of phishing
	AbuseType_ABUSE_PHISHING AbuseType = 1
	// A abuse report of a denial of service attack vector
	AbuseType_ABUSE_DOS AbuseType = 2
	// A abuse report of copyright infringement of any form
	AbuseType_ABUSE_COPYRIGHT_INFRINGEMENT AbuseType = 3
	// A abuse report of content which is against the law in most places
	// e.g. Child Pornography, Hate speech
	// NOTE: This category is not meant for unwanted political content, fake news and other undesirable content which is not illegal
	AbuseType_ABUSE_ILLEGAL_CONTENT AbuseType = 4
	// A abuse report of origin of a hacking attempts which were not requested, promoted or sanctioned by the victim
	AbuseType_ABUSE_UNSANCTIONED_HACKING AbuseType = 5
	// A abuse report of a location on the internet from where computer viruses are distributed
	AbuseType_ABUSE_VIRUS_DISTRIBUTION AbuseType = 6
)

var AbuseType_name = map[int32]string{
	0: "ABUSE_SPAM",
	1: "ABUSE_PHISHING",
	2: "ABUSE_DOS",
	3: "ABUSE_COPYRIGHT_INFRINGEMENT",
	4: "ABUSE_ILLEGAL_CONTENT",
	5: "ABUSE_UNSANCTIONED_HACKING",
	6: "ABUSE_VIRUS_DISTRIBUTION",
}
var AbuseType_value = map[string]int32{
	"ABUSE_SPAM":                   0,
	"ABUSE_PHISHING":               1,
	"ABUSE_DOS":                    2,
	"ABUSE_COPYRIGHT_INFRINGEMENT": 3,
	"ABUSE_ILLEGAL_CONTENT":        4,
	"ABUSE_UNSANCTIONED_HACKING":   5,
	"ABUSE_VIRUS_DISTRIBUTION":     6,
}

func (x AbuseType) String() string {
	return proto.EnumName(AbuseType_name, int32(x))
}
func (AbuseType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type DelistAcceptanceMethodType int32

const (
	// TODO add standardized acceptance methods
	DelistAcceptanceMethodType_DELIST_ACCEPTANCE_MANUAL DelistAcceptanceMethodType = 0
)

var DelistAcceptanceMethodType_name = map[int32]string{
	0: "DELIST_ACCEPTANCE_MANUAL",
}
var DelistAcceptanceMethodType_value = map[string]int32{
	"DELIST_ACCEPTANCE_MANUAL": 0,
}

func (x DelistAcceptanceMethodType) String() string {
	return proto.EnumName(DelistAcceptanceMethodType_name, int32(x))
}
func (DelistAcceptanceMethodType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type IPAddress struct {
	AddressFamily IPAddressFamily `protobuf:"varint,1,opt,name=address_family,json=addressFamily,enum=abusemesh.IPAddressFamily" json:"address_family,omitempty"`
	Address       string          `protobuf:"bytes,2,opt,name=address" json:"address,omitempty"`
}

func (m *IPAddress) Reset()                    { *m = IPAddress{} }
func (m *IPAddress) String() string            { return proto.CompactTextString(m) }
func (*IPAddress) ProtoMessage()               {}
func (*IPAddress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *IPAddress) GetAddressFamily() IPAddressFamily {
	if m != nil {
		return m.AddressFamily
	}
	return IPAddressFamily_IPFAMILY_IPV4
}

func (m *IPAddress) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type IPRange struct {
	Address *IPAddress `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	Prefix  int32      `protobuf:"varint,2,opt,name=prefix" json:"prefix,omitempty"`
}

func (m *IPRange) Reset()                    { *m = IPRange{} }
func (m *IPRange) String() string            { return proto.CompactTextString(m) }
func (*IPRange) ProtoMessage()               {}
func (*IPRange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *IPRange) GetAddress() *IPAddress {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *IPRange) GetPrefix() int32 {
	if m != nil {
		return m.Prefix
	}
	return 0
}

// UUID (Universally unique identifier)
type UUID struct {
	Uuid string `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
}

func (m *UUID) Reset()                    { *m = UUID{} }
func (m *UUID) String() string            { return proto.CompactTextString(m) }
func (*UUID) ProtoMessage()               {}
func (*UUID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *UUID) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

// A Neighbor is a node to which another node is directly connected.
type Neighbor struct {
	// The id of the neighbor message
	Id *UUID `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The id of the client node
	ClientNode *UUID `protobuf:"bytes,2,opt,name=client_node,json=clientNode" json:"client_node,omitempty"`
	// The id of the server node
	ServerNode *UUID `protobuf:"bytes,3,opt,name=server_node,json=serverNode" json:"server_node,omitempty"`
	// A signature of the client node which confirms the validity and integrity
	ClientSignature *PGPSignature `protobuf:"bytes,4,opt,name=client_signature,json=clientSignature" json:"client_signature,omitempty"`
}

func (m *Neighbor) Reset()                    { *m = Neighbor{} }
func (m *Neighbor) String() string            { return proto.CompactTextString(m) }
func (*Neighbor) ProtoMessage()               {}
func (*Neighbor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Neighbor) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Neighbor) GetClientNode() *UUID {
	if m != nil {
		return m.ClientNode
	}
	return nil
}

func (m *Neighbor) GetServerNode() *UUID {
	if m != nil {
		return m.ServerNode
	}
	return nil
}

func (m *Neighbor) GetClientSignature() *PGPSignature {
	if m != nil {
		return m.ClientSignature
	}
	return nil
}

// A node is a application which speaks the AbuseMesh protocol
type Node struct {
	// The ID of the node
	Uuid *UUID `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// The semantic version of the AbuseMesh protocol in use by the node
	ProtocolVersion string `protobuf:"bytes,2,opt,name=protocol_version,json=protocolVersion" json:"protocol_version,omitempty"`
	// The IP address on which the node is reachable
	IpAddress *IPAddress `protobuf:"bytes,3,opt,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	// Details about how to contact the the company and/of administrators of a node
	ContactDetails *ContactDetails `protobuf:"bytes,4,opt,name=contact_details,json=contactDetails" json:"contact_details,omitempty"`
	// The number of the autonomous system for which this node claims to have authority
	ASN int32 `protobuf:"varint,5,opt,name=ASN" json:"ASN,omitempty"`
	// The PGP entity which the node uses to sign its messages
	PgpEntity *PGPEntity `protobuf:"bytes,6,opt,name=pgp_entity,json=pgpEntity" json:"pgp_entity,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Node) GetUuid() *UUID {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *Node) GetProtocolVersion() string {
	if m != nil {
		return m.ProtocolVersion
	}
	return ""
}

func (m *Node) GetIpAddress() *IPAddress {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *Node) GetContactDetails() *ContactDetails {
	if m != nil {
		return m.ContactDetails
	}
	return nil
}

func (m *Node) GetASN() int32 {
	if m != nil {
		return m.ASN
	}
	return 0
}

func (m *Node) GetPgpEntity() *PGPEntity {
	if m != nil {
		return m.PgpEntity
	}
	return nil
}

type ContactDetails struct {
	OrganizationName string                   `protobuf:"bytes,1,opt,name=organization_name,json=organizationName" json:"organization_name,omitempty"`
	EmailAddress     string                   `protobuf:"bytes,2,opt,name=email_address,json=emailAddress" json:"email_address,omitempty"`
	PhoneNumber      string                   `protobuf:"bytes,3,opt,name=phone_number,json=phoneNumber" json:"phone_number,omitempty"`
	PhysicalAddress  string                   `protobuf:"bytes,4,opt,name=physical_address,json=physicalAddress" json:"physical_address,omitempty"`
	ContactPersons   []*ContactDetails_Person `protobuf:"bytes,5,rep,name=contact_persons,json=contactPersons" json:"contact_persons,omitempty"`
}

func (m *ContactDetails) Reset()                    { *m = ContactDetails{} }
func (m *ContactDetails) String() string            { return proto.CompactTextString(m) }
func (*ContactDetails) ProtoMessage()               {}
func (*ContactDetails) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ContactDetails) GetOrganizationName() string {
	if m != nil {
		return m.OrganizationName
	}
	return ""
}

func (m *ContactDetails) GetEmailAddress() string {
	if m != nil {
		return m.EmailAddress
	}
	return ""
}

func (m *ContactDetails) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *ContactDetails) GetPhysicalAddress() string {
	if m != nil {
		return m.PhysicalAddress
	}
	return ""
}

func (m *ContactDetails) GetContactPersons() []*ContactDetails_Person {
	if m != nil {
		return m.ContactPersons
	}
	return nil
}

type ContactDetails_Person struct {
	FirstName    string `protobuf:"bytes,6,opt,name=first_name,json=firstName" json:"first_name,omitempty"`
	MiddleName   string `protobuf:"bytes,7,opt,name=middle_name,json=middleName" json:"middle_name,omitempty"`
	LastName     string `protobuf:"bytes,8,opt,name=last_name,json=lastName" json:"last_name,omitempty"`
	JobTitle     string `protobuf:"bytes,9,opt,name=job_title,json=jobTitle" json:"job_title,omitempty"`
	EmailAddress string `protobuf:"bytes,10,opt,name=email_address,json=emailAddress" json:"email_address,omitempty"`
	PhoneNumber  string `protobuf:"bytes,11,opt,name=phone_number,json=phoneNumber" json:"phone_number,omitempty"`
}

func (m *ContactDetails_Person) Reset()                    { *m = ContactDetails_Person{} }
func (m *ContactDetails_Person) String() string            { return proto.CompactTextString(m) }
func (*ContactDetails_Person) ProtoMessage()               {}
func (*ContactDetails_Person) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

func (m *ContactDetails_Person) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *ContactDetails_Person) GetMiddleName() string {
	if m != nil {
		return m.MiddleName
	}
	return ""
}

func (m *ContactDetails_Person) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *ContactDetails_Person) GetJobTitle() string {
	if m != nil {
		return m.JobTitle
	}
	return ""
}

func (m *ContactDetails_Person) GetEmailAddress() string {
	if m != nil {
		return m.EmailAddress
	}
	return ""
}

func (m *ContactDetails_Person) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

type PGPEntity struct {
	// The PGP packets of this pgp entity: the public key, userids, signatures and subkeys in binary format
	PgpPackets []byte `protobuf:"bytes,1,opt,name=pgp_packets,json=pgpPackets,proto3" json:"pgp_packets,omitempty"`
}

func (m *PGPEntity) Reset()                    { *m = PGPEntity{} }
func (m *PGPEntity) String() string            { return proto.CompactTextString(m) }
func (*PGPEntity) ProtoMessage()               {}
func (*PGPEntity) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *PGPEntity) GetPgpPackets() []byte {
	if m != nil {
		return m.PgpPackets
	}
	return nil
}

type PGPSignature struct {
	// A PGP detached signature packet of data
	Signature []byte `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *PGPSignature) Reset()                    { *m = PGPSignature{} }
func (m *PGPSignature) String() string            { return proto.CompactTextString(m) }
func (*PGPSignature) ProtoMessage()               {}
func (*PGPSignature) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *PGPSignature) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type Report struct {
	// The id of the report
	Uuid *UUID `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// The id of the node which created the report
	Reporter *UUID `protobuf:"bytes,2,opt,name=reporter" json:"reporter,omitempty"`
	// The id of the node which claims ownership over the AS where the abuse originated
	Suspect *UUID `protobuf:"bytes,3,opt,name=suspect" json:"suspect,omitempty"`
	// The signature that proves the reporter it the author of the report and that the report has no been modified
	Signature *PGPSignature `protobuf:"bytes,4,opt,name=signature" json:"signature,omitempty"`
	// The type of abuse this report specifies
	//
	// Types that are valid to be assigned to ReportAbuseType:
	//	*Report_UnstandardizedAbuseType
	//	*Report_AbuseType
	ReportAbuseType isReport_ReportAbuseType `protobuf_oneof:"report_abuse_type"`
	// A human readable description to give context
	// WARNING: this field should not be used for evidence, metadata or other machine data.
	Description string `protobuf:"bytes,7,opt,name=description" json:"description,omitempty"`
	// Types that are valid to be assigned to AbuseOrigin:
	//	*Report_Email
	//	*Report_DomainName
	//	*Report_Url
	//	*Report_Ip
	//	*Report_IpRange
	AbuseOrigin isReport_AbuseOrigin `protobuf_oneof:"abuse_origin"`
	// A key value map of evidence of abuse
	// e.g. when reporting spam, the recieved email can be included
	// e.g. for illegal scanning a log can be included
	// e.g. when reporting a DoS attack a anonymised PCAP can be included
	Evidence map[string]*Evidence `protobuf:"bytes,13,rep,name=evidence" json:"evidence,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// A map containing extra details about the abuse type
	// e.g. when reporting a DoS attack the type of DOS attack can be a metadata field
	// TODO maybe this should be standardized as well at some point
	AbuseTypeMetadata map[string]string `protobuf:"bytes,14,rep,name=abuse_type_metadata,json=abuseTypeMetadata" json:"abuse_type_metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// How was the abuse detected
	// e.g. spam filter
	// e.g. DDoS detector
	// e.g. human entry
	DetectionMethod *AbuseDetectionMethod `protobuf:"bytes,15,opt,name=detection_method,json=detectionMethod" json:"detection_method,omitempty"`
	// A map containing extra details about the detection method
	// e.g. which software version was used to detect the abuse
	// e.g. who created this report manually
	// TODO maybe this should be standardized as well at some point
	DetectionMethodMetadata map[string]string `protobuf:"bytes,16,rep,name=detection_method_metadata,json=detectionMethodMetadata" json:"detection_method_metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Report) Reset()                    { *m = Report{} }
func (m *Report) String() string            { return proto.CompactTextString(m) }
func (*Report) ProtoMessage()               {}
func (*Report) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type isReport_ReportAbuseType interface {
	isReport_ReportAbuseType()
}
type isReport_AbuseOrigin interface {
	isReport_AbuseOrigin()
}

type Report_UnstandardizedAbuseType struct {
	UnstandardizedAbuseType string `protobuf:"bytes,5,opt,name=unstandardized_abuse_type,json=unstandardizedAbuseType,oneof"`
}
type Report_AbuseType struct {
	AbuseType AbuseType `protobuf:"varint,6,opt,name=abuse_type,json=abuseType,enum=abusemesh.AbuseType,oneof"`
}
type Report_Email struct {
	Email string `protobuf:"bytes,8,opt,name=email,oneof"`
}
type Report_DomainName struct {
	DomainName string `protobuf:"bytes,9,opt,name=domain_name,json=domainName,oneof"`
}
type Report_Url struct {
	Url string `protobuf:"bytes,10,opt,name=url,oneof"`
}
type Report_Ip struct {
	Ip *IPAddress `protobuf:"bytes,11,opt,name=ip,oneof"`
}
type Report_IpRange struct {
	IpRange *IPRange `protobuf:"bytes,12,opt,name=ip_range,json=ipRange,oneof"`
}

func (*Report_UnstandardizedAbuseType) isReport_ReportAbuseType() {}
func (*Report_AbuseType) isReport_ReportAbuseType()               {}
func (*Report_Email) isReport_AbuseOrigin()                       {}
func (*Report_DomainName) isReport_AbuseOrigin()                  {}
func (*Report_Url) isReport_AbuseOrigin()                         {}
func (*Report_Ip) isReport_AbuseOrigin()                          {}
func (*Report_IpRange) isReport_AbuseOrigin()                     {}

func (m *Report) GetReportAbuseType() isReport_ReportAbuseType {
	if m != nil {
		return m.ReportAbuseType
	}
	return nil
}
func (m *Report) GetAbuseOrigin() isReport_AbuseOrigin {
	if m != nil {
		return m.AbuseOrigin
	}
	return nil
}

func (m *Report) GetUuid() *UUID {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *Report) GetReporter() *UUID {
	if m != nil {
		return m.Reporter
	}
	return nil
}

func (m *Report) GetSuspect() *UUID {
	if m != nil {
		return m.Suspect
	}
	return nil
}

func (m *Report) GetSignature() *PGPSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Report) GetUnstandardizedAbuseType() string {
	if x, ok := m.GetReportAbuseType().(*Report_UnstandardizedAbuseType); ok {
		return x.UnstandardizedAbuseType
	}
	return ""
}

func (m *Report) GetAbuseType() AbuseType {
	if x, ok := m.GetReportAbuseType().(*Report_AbuseType); ok {
		return x.AbuseType
	}
	return AbuseType_ABUSE_SPAM
}

func (m *Report) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Report) GetEmail() string {
	if x, ok := m.GetAbuseOrigin().(*Report_Email); ok {
		return x.Email
	}
	return ""
}

func (m *Report) GetDomainName() string {
	if x, ok := m.GetAbuseOrigin().(*Report_DomainName); ok {
		return x.DomainName
	}
	return ""
}

func (m *Report) GetUrl() string {
	if x, ok := m.GetAbuseOrigin().(*Report_Url); ok {
		return x.Url
	}
	return ""
}

func (m *Report) GetIp() *IPAddress {
	if x, ok := m.GetAbuseOrigin().(*Report_Ip); ok {
		return x.Ip
	}
	return nil
}

func (m *Report) GetIpRange() *IPRange {
	if x, ok := m.GetAbuseOrigin().(*Report_IpRange); ok {
		return x.IpRange
	}
	return nil
}

func (m *Report) GetEvidence() map[string]*Evidence {
	if m != nil {
		return m.Evidence
	}
	return nil
}

func (m *Report) GetAbuseTypeMetadata() map[string]string {
	if m != nil {
		return m.AbuseTypeMetadata
	}
	return nil
}

func (m *Report) GetDetectionMethod() *AbuseDetectionMethod {
	if m != nil {
		return m.DetectionMethod
	}
	return nil
}

func (m *Report) GetDetectionMethodMetadata() map[string]string {
	if m != nil {
		return m.DetectionMethodMetadata
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Report) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Report_OneofMarshaler, _Report_OneofUnmarshaler, _Report_OneofSizer, []interface{}{
		(*Report_UnstandardizedAbuseType)(nil),
		(*Report_AbuseType)(nil),
		(*Report_Email)(nil),
		(*Report_DomainName)(nil),
		(*Report_Url)(nil),
		(*Report_Ip)(nil),
		(*Report_IpRange)(nil),
	}
}

func _Report_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Report)
	// report_abuse_type
	switch x := m.ReportAbuseType.(type) {
	case *Report_UnstandardizedAbuseType:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.UnstandardizedAbuseType)
	case *Report_AbuseType:
		b.EncodeVarint(6<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.AbuseType))
	case nil:
	default:
		return fmt.Errorf("Report.ReportAbuseType has unexpected type %T", x)
	}
	// abuse_origin
	switch x := m.AbuseOrigin.(type) {
	case *Report_Email:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Email)
	case *Report_DomainName:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.DomainName)
	case *Report_Url:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Url)
	case *Report_Ip:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ip); err != nil {
			return err
		}
	case *Report_IpRange:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpRange); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Report.AbuseOrigin has unexpected type %T", x)
	}
	return nil
}

func _Report_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Report)
	switch tag {
	case 5: // report_abuse_type.unstandardized_abuse_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ReportAbuseType = &Report_UnstandardizedAbuseType{x}
		return true, err
	case 6: // report_abuse_type.abuse_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ReportAbuseType = &Report_AbuseType{AbuseType(x)}
		return true, err
	case 8: // abuse_origin.email
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.AbuseOrigin = &Report_Email{x}
		return true, err
	case 9: // abuse_origin.domain_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.AbuseOrigin = &Report_DomainName{x}
		return true, err
	case 10: // abuse_origin.url
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.AbuseOrigin = &Report_Url{x}
		return true, err
	case 11: // abuse_origin.ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPAddress)
		err := b.DecodeMessage(msg)
		m.AbuseOrigin = &Report_Ip{msg}
		return true, err
	case 12: // abuse_origin.ip_range
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPRange)
		err := b.DecodeMessage(msg)
		m.AbuseOrigin = &Report_IpRange{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Report_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Report)
	// report_abuse_type
	switch x := m.ReportAbuseType.(type) {
	case *Report_UnstandardizedAbuseType:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.UnstandardizedAbuseType)))
		n += len(x.UnstandardizedAbuseType)
	case *Report_AbuseType:
		n += proto.SizeVarint(6<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.AbuseType))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// abuse_origin
	switch x := m.AbuseOrigin.(type) {
	case *Report_Email:
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Email)))
		n += len(x.Email)
	case *Report_DomainName:
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.DomainName)))
		n += len(x.DomainName)
	case *Report_Url:
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Url)))
		n += len(x.Url)
	case *Report_Ip:
		s := proto.Size(x.Ip)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Report_IpRange:
		s := proto.Size(x.IpRange)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A report confirmation can be created by a node which claims to have checked the report indepenantly and confirms the abuse report
// A report confirmation therefor must also provide evidence
type ReportConfirmation struct {
	// The id of the report confirmation
	Uuid *UUID `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// The id of node that created the confirmation
	Node *UUID `protobuf:"bytes,2,opt,name=node" json:"node,omitempty"`
	// The id of the report that is confirmed by this message
	Report *UUID `protobuf:"bytes,3,opt,name=report" json:"report,omitempty"`
	// The signature that proves the reporter it the author of the report and that the report has not been modified
	Signature *PGPSignature `protobuf:"bytes,4,opt,name=signature" json:"signature,omitempty"`
	// A human readable description of the confirmation
	// WARNING: this field should not be used for evidence or other machine data.
	Description string `protobuf:"bytes,5,opt,name=description" json:"description,omitempty"`
	// A key value map of evidence of abuse which should be indepently gathered
	// e.g. when reporting copyright infringement a http request and response can be added
	// e.g. when reporting a DoS attack a anonymised PCAP can be included
	Evidence map[string]*Evidence `protobuf:"bytes,6,rep,name=evidence" json:"evidence,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// How was the abuse detected
	// e.g. spam filter
	// e.g. DDoS detector
	// e.g. human entry
	DetectionMethod *AbuseDetectionMethod `protobuf:"bytes,7,opt,name=detection_method,json=detectionMethod" json:"detection_method,omitempty"`
	// A map containing extra details about the detection method
	// e.g. which software version was used to detect the abuse
	// e.g. who created this report manually
	// TODO maybe this should be standardized as well at some point
	DetectionMethodMetadata map[string]string `protobuf:"bytes,8,rep,name=detection_method_metadata,json=detectionMethodMetadata" json:"detection_method_metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ReportConfirmation) Reset()                    { *m = ReportConfirmation{} }
func (m *ReportConfirmation) String() string            { return proto.CompactTextString(m) }
func (*ReportConfirmation) ProtoMessage()               {}
func (*ReportConfirmation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ReportConfirmation) GetUuid() *UUID {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *ReportConfirmation) GetNode() *UUID {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *ReportConfirmation) GetReport() *UUID {
	if m != nil {
		return m.Report
	}
	return nil
}

func (m *ReportConfirmation) GetSignature() *PGPSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *ReportConfirmation) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ReportConfirmation) GetEvidence() map[string]*Evidence {
	if m != nil {
		return m.Evidence
	}
	return nil
}

func (m *ReportConfirmation) GetDetectionMethod() *AbuseDetectionMethod {
	if m != nil {
		return m.DetectionMethod
	}
	return nil
}

func (m *ReportConfirmation) GetDetectionMethodMetadata() map[string]string {
	if m != nil {
		return m.DetectionMethodMetadata
	}
	return nil
}

type AbuseDetectionMethod struct {
	// Types that are valid to be assigned to DetectionMethod:
	//	*AbuseDetectionMethod_UnstandardizedDetectionMethod
	//	*AbuseDetectionMethod_DetectionMethodType
	DetectionMethod isAbuseDetectionMethod_DetectionMethod `protobuf_oneof:"detection_method"`
}

func (m *AbuseDetectionMethod) Reset()                    { *m = AbuseDetectionMethod{} }
func (m *AbuseDetectionMethod) String() string            { return proto.CompactTextString(m) }
func (*AbuseDetectionMethod) ProtoMessage()               {}
func (*AbuseDetectionMethod) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type isAbuseDetectionMethod_DetectionMethod interface {
	isAbuseDetectionMethod_DetectionMethod()
}

type AbuseDetectionMethod_UnstandardizedDetectionMethod struct {
	UnstandardizedDetectionMethod string `protobuf:"bytes,1,opt,name=unstandardized_detection_method,json=unstandardizedDetectionMethod,oneof"`
}
type AbuseDetectionMethod_DetectionMethodType struct {
	DetectionMethodType AbuseDetectionMethodType `protobuf:"varint,2,opt,name=detection_method_type,json=detectionMethodType,enum=abusemesh.AbuseDetectionMethodType,oneof"`
}

func (*AbuseDetectionMethod_UnstandardizedDetectionMethod) isAbuseDetectionMethod_DetectionMethod() {}
func (*AbuseDetectionMethod_DetectionMethodType) isAbuseDetectionMethod_DetectionMethod()           {}

func (m *AbuseDetectionMethod) GetDetectionMethod() isAbuseDetectionMethod_DetectionMethod {
	if m != nil {
		return m.DetectionMethod
	}
	return nil
}

func (m *AbuseDetectionMethod) GetUnstandardizedDetectionMethod() string {
	if x, ok := m.GetDetectionMethod().(*AbuseDetectionMethod_UnstandardizedDetectionMethod); ok {
		return x.UnstandardizedDetectionMethod
	}
	return ""
}

func (m *AbuseDetectionMethod) GetDetectionMethodType() AbuseDetectionMethodType {
	if x, ok := m.GetDetectionMethod().(*AbuseDetectionMethod_DetectionMethodType); ok {
		return x.DetectionMethodType
	}
	return AbuseDetectionMethodType_ABUSE_DETECTION_MANUAL
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AbuseDetectionMethod) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AbuseDetectionMethod_OneofMarshaler, _AbuseDetectionMethod_OneofUnmarshaler, _AbuseDetectionMethod_OneofSizer, []interface{}{
		(*AbuseDetectionMethod_UnstandardizedDetectionMethod)(nil),
		(*AbuseDetectionMethod_DetectionMethodType)(nil),
	}
}

func _AbuseDetectionMethod_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AbuseDetectionMethod)
	// detection_method
	switch x := m.DetectionMethod.(type) {
	case *AbuseDetectionMethod_UnstandardizedDetectionMethod:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.UnstandardizedDetectionMethod)
	case *AbuseDetectionMethod_DetectionMethodType:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.DetectionMethodType))
	case nil:
	default:
		return fmt.Errorf("AbuseDetectionMethod.DetectionMethod has unexpected type %T", x)
	}
	return nil
}

func _AbuseDetectionMethod_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AbuseDetectionMethod)
	switch tag {
	case 1: // detection_method.unstandardized_detection_method
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.DetectionMethod = &AbuseDetectionMethod_UnstandardizedDetectionMethod{x}
		return true, err
	case 2: // detection_method.detection_method_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.DetectionMethod = &AbuseDetectionMethod_DetectionMethodType{AbuseDetectionMethodType(x)}
		return true, err
	default:
		return false, nil
	}
}

func _AbuseDetectionMethod_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AbuseDetectionMethod)
	// detection_method
	switch x := m.DetectionMethod.(type) {
	case *AbuseDetectionMethod_UnstandardizedDetectionMethod:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.UnstandardizedDetectionMethod)))
		n += len(x.UnstandardizedDetectionMethod)
	case *AbuseDetectionMethod_DetectionMethodType:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.DetectionMethodType))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Evidence struct {
	// Types that are valid to be assigned to EvidenceType:
	//	*Evidence_UnstandardizedEvidenceType
	//	*Evidence_Type
	EvidenceType isEvidence_EvidenceType `protobuf_oneof:"evidence_type"`
	EvidenceData []byte                  `protobuf:"bytes,3,opt,name=evidence_data,json=evidenceData,proto3" json:"evidence_data,omitempty"`
}

func (m *Evidence) Reset()                    { *m = Evidence{} }
func (m *Evidence) String() string            { return proto.CompactTextString(m) }
func (*Evidence) ProtoMessage()               {}
func (*Evidence) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type isEvidence_EvidenceType interface {
	isEvidence_EvidenceType()
}

type Evidence_UnstandardizedEvidenceType struct {
	UnstandardizedEvidenceType string `protobuf:"bytes,1,opt,name=unstandardized_evidence_type,json=unstandardizedEvidenceType,oneof"`
}
type Evidence_Type struct {
	Type EvidenceType `protobuf:"varint,2,opt,name=type,enum=abusemesh.EvidenceType,oneof"`
}

func (*Evidence_UnstandardizedEvidenceType) isEvidence_EvidenceType() {}
func (*Evidence_Type) isEvidence_EvidenceType()                       {}

func (m *Evidence) GetEvidenceType() isEvidence_EvidenceType {
	if m != nil {
		return m.EvidenceType
	}
	return nil
}

func (m *Evidence) GetUnstandardizedEvidenceType() string {
	if x, ok := m.GetEvidenceType().(*Evidence_UnstandardizedEvidenceType); ok {
		return x.UnstandardizedEvidenceType
	}
	return ""
}

func (m *Evidence) GetType() EvidenceType {
	if x, ok := m.GetEvidenceType().(*Evidence_Type); ok {
		return x.Type
	}
	return EvidenceType_EVIDENCE_URL
}

func (m *Evidence) GetEvidenceData() []byte {
	if m != nil {
		return m.EvidenceData
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Evidence) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Evidence_OneofMarshaler, _Evidence_OneofUnmarshaler, _Evidence_OneofSizer, []interface{}{
		(*Evidence_UnstandardizedEvidenceType)(nil),
		(*Evidence_Type)(nil),
	}
}

func _Evidence_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Evidence)
	// evidence_type
	switch x := m.EvidenceType.(type) {
	case *Evidence_UnstandardizedEvidenceType:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.UnstandardizedEvidenceType)
	case *Evidence_Type:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Type))
	case nil:
	default:
		return fmt.Errorf("Evidence.EvidenceType has unexpected type %T", x)
	}
	return nil
}

func _Evidence_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Evidence)
	switch tag {
	case 1: // evidence_type.unstandardized_evidence_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.EvidenceType = &Evidence_UnstandardizedEvidenceType{x}
		return true, err
	case 2: // evidence_type.type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.EvidenceType = &Evidence_Type{EvidenceType(x)}
		return true, err
	default:
		return false, nil
	}
}

func _Evidence_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Evidence)
	// evidence_type
	switch x := m.EvidenceType.(type) {
	case *Evidence_UnstandardizedEvidenceType:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.UnstandardizedEvidenceType)))
		n += len(x.UnstandardizedEvidenceType)
	case *Evidence_Type:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Type))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type DelistRequest struct {
	// The id of the delist request
	Uuid *UUID `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// The report to be delisted
	Report *UUID `protobuf:"bytes,2,opt,name=report" json:"report,omitempty"`
	// The node which requested the delisting
	Node *Node `protobuf:"bytes,3,opt,name=node" json:"node,omitempty"`
	// The signature that proves the requester it the author of the delist request and that the delist request has not been modified
	Signature *PGPSignature `protobuf:"bytes,4,opt,name=signature" json:"signature,omitempty"`
	// A human readable description which may explain why a report is incorrect or has been resolved
	Description string `protobuf:"bytes,5,opt,name=description" json:"description,omitempty"`
	// A key value map of evidence which proves a report is incorrect or resolved
	// e.g. a letter of consent when appealing a scanning abuse report
	// e.g. a link to a court case
	Evidence map[string]*Evidence `protobuf:"bytes,6,rep,name=evidence" json:"evidence,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// A map containing extra details
	// e.g. when reporting a DOS attack the type of DOS attack can be a metadata field
	// TODO maybe this should be standardized as well at some point
	Metadata map[string]string `protobuf:"bytes,7,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *DelistRequest) Reset()                    { *m = DelistRequest{} }
func (m *DelistRequest) String() string            { return proto.CompactTextString(m) }
func (*DelistRequest) ProtoMessage()               {}
func (*DelistRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *DelistRequest) GetUuid() *UUID {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *DelistRequest) GetReport() *UUID {
	if m != nil {
		return m.Report
	}
	return nil
}

func (m *DelistRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *DelistRequest) GetSignature() *PGPSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *DelistRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *DelistRequest) GetEvidence() map[string]*Evidence {
	if m != nil {
		return m.Evidence
	}
	return nil
}

func (m *DelistRequest) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type DelistAcceptance struct {
	// The id of the delist acceptance
	Uuid *UUID `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// The id of the delist request
	DelistRequest *UUID `protobuf:"bytes,2,opt,name=delist_request,json=delistRequest" json:"delist_request,omitempty"`
	// The node which accepted the delisting request
	Node *Node `protobuf:"bytes,3,opt,name=node" json:"node,omitempty"`
	// The signature that proves the node it the author of the delist acceptance and that the delist acceptance has not been modified
	Signature *PGPSignature `protobuf:"bytes,4,opt,name=signature" json:"signature,omitempty"`
	// A human readable description which may explain why the delist request was accepted
	Description string `protobuf:"bytes,5,opt,name=description" json:"description,omitempty"`
	// A key value map of evidence which proves a report is incorrect or resolved
	// e.g. http request and response to a url which now returns a 404 in case of copyright infringement
	Evidence map[string]*Evidence `protobuf:"bytes,6,rep,name=evidence" json:"evidence,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The method which was used to accept this method
	// e.g. manual(human check)
	// e.g. automated copyright check tool
	AcceptanceMethod *DelistAcceptanceMethod `protobuf:"bytes,7,opt,name=acceptance_method,json=acceptanceMethod" json:"acceptance_method,omitempty"`
	// A map containing extra details about the acceptance method
	// e.g. what is the name, version and source code of a scanner
	// e.g. Which human checked the delist request
	// TODO maybe this should be standardized as well at some point
	AcceptanceMethodMetadata map[string]string `protobuf:"bytes,8,rep,name=acceptance_method_metadata,json=acceptanceMethodMetadata" json:"acceptance_method_metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *DelistAcceptance) Reset()                    { *m = DelistAcceptance{} }
func (m *DelistAcceptance) String() string            { return proto.CompactTextString(m) }
func (*DelistAcceptance) ProtoMessage()               {}
func (*DelistAcceptance) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *DelistAcceptance) GetUuid() *UUID {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *DelistAcceptance) GetDelistRequest() *UUID {
	if m != nil {
		return m.DelistRequest
	}
	return nil
}

func (m *DelistAcceptance) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *DelistAcceptance) GetSignature() *PGPSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *DelistAcceptance) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *DelistAcceptance) GetEvidence() map[string]*Evidence {
	if m != nil {
		return m.Evidence
	}
	return nil
}

func (m *DelistAcceptance) GetAcceptanceMethod() *DelistAcceptanceMethod {
	if m != nil {
		return m.AcceptanceMethod
	}
	return nil
}

func (m *DelistAcceptance) GetAcceptanceMethodMetadata() map[string]string {
	if m != nil {
		return m.AcceptanceMethodMetadata
	}
	return nil
}

type DelistAcceptanceMethod struct {
	// Types that are valid to be assigned to AcceptanceMethod:
	//	*DelistAcceptanceMethod_UnstandardizedAcceptanceMethodType
	//	*DelistAcceptanceMethod_MethodType
	AcceptanceMethod isDelistAcceptanceMethod_AcceptanceMethod `protobuf_oneof:"acceptance_method"`
}

func (m *DelistAcceptanceMethod) Reset()                    { *m = DelistAcceptanceMethod{} }
func (m *DelistAcceptanceMethod) String() string            { return proto.CompactTextString(m) }
func (*DelistAcceptanceMethod) ProtoMessage()               {}
func (*DelistAcceptanceMethod) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

type isDelistAcceptanceMethod_AcceptanceMethod interface {
	isDelistAcceptanceMethod_AcceptanceMethod()
}

type DelistAcceptanceMethod_UnstandardizedAcceptanceMethodType struct {
	UnstandardizedAcceptanceMethodType string `protobuf:"bytes,1,opt,name=unstandardized_acceptance_method_type,json=unstandardizedAcceptanceMethodType,oneof"`
}
type DelistAcceptanceMethod_MethodType struct {
	MethodType DelistAcceptanceMethodType `protobuf:"varint,2,opt,name=method_type,json=methodType,enum=abusemesh.DelistAcceptanceMethodType,oneof"`
}

func (*DelistAcceptanceMethod_UnstandardizedAcceptanceMethodType) isDelistAcceptanceMethod_AcceptanceMethod() {
}
func (*DelistAcceptanceMethod_MethodType) isDelistAcceptanceMethod_AcceptanceMethod() {}

func (m *DelistAcceptanceMethod) GetAcceptanceMethod() isDelistAcceptanceMethod_AcceptanceMethod {
	if m != nil {
		return m.AcceptanceMethod
	}
	return nil
}

func (m *DelistAcceptanceMethod) GetUnstandardizedAcceptanceMethodType() string {
	if x, ok := m.GetAcceptanceMethod().(*DelistAcceptanceMethod_UnstandardizedAcceptanceMethodType); ok {
		return x.UnstandardizedAcceptanceMethodType
	}
	return ""
}

func (m *DelistAcceptanceMethod) GetMethodType() DelistAcceptanceMethodType {
	if x, ok := m.GetAcceptanceMethod().(*DelistAcceptanceMethod_MethodType); ok {
		return x.MethodType
	}
	return DelistAcceptanceMethodType_DELIST_ACCEPTANCE_MANUAL
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DelistAcceptanceMethod) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DelistAcceptanceMethod_OneofMarshaler, _DelistAcceptanceMethod_OneofUnmarshaler, _DelistAcceptanceMethod_OneofSizer, []interface{}{
		(*DelistAcceptanceMethod_UnstandardizedAcceptanceMethodType)(nil),
		(*DelistAcceptanceMethod_MethodType)(nil),
	}
}

func _DelistAcceptanceMethod_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DelistAcceptanceMethod)
	// acceptance_method
	switch x := m.AcceptanceMethod.(type) {
	case *DelistAcceptanceMethod_UnstandardizedAcceptanceMethodType:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.UnstandardizedAcceptanceMethodType)
	case *DelistAcceptanceMethod_MethodType:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.MethodType))
	case nil:
	default:
		return fmt.Errorf("DelistAcceptanceMethod.AcceptanceMethod has unexpected type %T", x)
	}
	return nil
}

func _DelistAcceptanceMethod_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DelistAcceptanceMethod)
	switch tag {
	case 1: // acceptance_method.unstandardized_acceptance_method_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.AcceptanceMethod = &DelistAcceptanceMethod_UnstandardizedAcceptanceMethodType{x}
		return true, err
	case 2: // acceptance_method.method_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.AcceptanceMethod = &DelistAcceptanceMethod_MethodType{DelistAcceptanceMethodType(x)}
		return true, err
	default:
		return false, nil
	}
}

func _DelistAcceptanceMethod_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DelistAcceptanceMethod)
	// acceptance_method
	switch x := m.AcceptanceMethod.(type) {
	case *DelistAcceptanceMethod_UnstandardizedAcceptanceMethodType:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.UnstandardizedAcceptanceMethodType)))
		n += len(x.UnstandardizedAcceptanceMethodType)
	case *DelistAcceptanceMethod_MethodType:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.MethodType))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*IPAddress)(nil), "abusemesh.IPAddress")
	proto.RegisterType((*IPRange)(nil), "abusemesh.IPRange")
	proto.RegisterType((*UUID)(nil), "abusemesh.UUID")
	proto.RegisterType((*Neighbor)(nil), "abusemesh.Neighbor")
	proto.RegisterType((*Node)(nil), "abusemesh.Node")
	proto.RegisterType((*ContactDetails)(nil), "abusemesh.ContactDetails")
	proto.RegisterType((*ContactDetails_Person)(nil), "abusemesh.ContactDetails.Person")
	proto.RegisterType((*PGPEntity)(nil), "abusemesh.PGPEntity")
	proto.RegisterType((*PGPSignature)(nil), "abusemesh.PGPSignature")
	proto.RegisterType((*Report)(nil), "abusemesh.Report")
	proto.RegisterType((*ReportConfirmation)(nil), "abusemesh.ReportConfirmation")
	proto.RegisterType((*AbuseDetectionMethod)(nil), "abusemesh.AbuseDetectionMethod")
	proto.RegisterType((*Evidence)(nil), "abusemesh.Evidence")
	proto.RegisterType((*DelistRequest)(nil), "abusemesh.DelistRequest")
	proto.RegisterType((*DelistAcceptance)(nil), "abusemesh.DelistAcceptance")
	proto.RegisterType((*DelistAcceptanceMethod)(nil), "abusemesh.DelistAcceptanceMethod")
	proto.RegisterEnum("abusemesh.IPAddressFamily", IPAddressFamily_name, IPAddressFamily_value)
	proto.RegisterEnum("abusemesh.AbuseDetectionMethodType", AbuseDetectionMethodType_name, AbuseDetectionMethodType_value)
	proto.RegisterEnum("abusemesh.EvidenceType", EvidenceType_name, EvidenceType_value)
	proto.RegisterEnum("abusemesh.AbuseType", AbuseType_name, AbuseType_value)
	proto.RegisterEnum("abusemesh.DelistAcceptanceMethodType", DelistAcceptanceMethodType_name, DelistAcceptanceMethodType_value)
}

func init() { proto.RegisterFile("abuse-mesh-common.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1661 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcd, 0x72, 0xe3, 0x58,
	0x15, 0x8e, 0xfc, 0x17, 0xeb, 0xf8, 0x4f, 0xb9, 0xe9, 0x49, 0x1c, 0x93, 0x26, 0x69, 0x77, 0xcd,
	0x90, 0xa4, 0xa7, 0x03, 0x95, 0x61, 0x1a, 0xe8, 0x61, 0x23, 0xdb, 0x6a, 0x5b, 0x33, 0x8e, 0x22,
	0x64, 0x3b, 0x45, 0x56, 0x2a, 0xc5, 0xba, 0x49, 0xd4, 0x63, 0x4b, 0x42, 0x92, 0x03, 0x99, 0x57,
	0x60, 0xcf, 0x8a, 0xb7, 0x60, 0xc5, 0x1b, 0x50, 0x14, 0x55, 0x2c, 0xe6, 0x4d, 0x78, 0x02, 0x4a,
	0xf7, 0x4a, 0xb6, 0x7e, 0x6c, 0x27, 0xd3, 0x45, 0x17, 0xb3, 0xbb, 0xf7, 0x9c, 0xef, 0x9c, 0x7b,
	0xfe, 0x8f, 0x65, 0xd8, 0xd5, 0xae, 0x67, 0x2e, 0x7e, 0x3d, 0xc5, 0xee, 0xdd, 0xeb, 0xb1, 0x35,
	0x9d, 0x5a, 0xe6, 0xa9, 0xed, 0x58, 0x9e, 0x85, 0x58, 0xc2, 0xf0, 0xe9, 0xcd, 0x3b, 0x60, 0x45,
	0x99, 0xd7, 0x75, 0x07, 0xbb, 0x2e, 0xe2, 0xa1, 0xaa, 0xd1, 0xa3, 0x7a, 0xa3, 0x4d, 0x8d, 0xc9,
	0x43, 0x9d, 0x39, 0x64, 0x8e, 0xaa, 0x67, 0x8d, 0xd3, 0xb9, 0xc0, 0xe9, 0x1c, 0xfd, 0x8e, 0x20,
	0x94, 0x8a, 0x16, 0xbd, 0xa2, 0x3a, 0x6c, 0x06, 0x84, 0x7a, 0xe6, 0x90, 0x39, 0x62, 0x95, 0xf0,
	0xda, 0xfc, 0x1d, 0x6c, 0x8a, 0xb2, 0xa2, 0x99, 0xb7, 0x18, 0x9d, 0x2e, 0x40, 0xfe, 0x03, 0xa5,
	0xb3, 0x67, 0xcb, 0x1e, 0x98, 0x8b, 0xa2, 0x1d, 0x28, 0xd8, 0x0e, 0xbe, 0x31, 0xfe, 0x44, 0x74,
	0xe6, 0x95, 0xe0, 0xd6, 0x6c, 0x40, 0x6e, 0x34, 0x12, 0x3b, 0x08, 0x41, 0x6e, 0x36, 0x33, 0x74,
	0xa2, 0x8c, 0x55, 0xc8, 0xb9, 0xf9, 0x3d, 0x03, 0x45, 0x09, 0x1b, 0xb7, 0x77, 0xd7, 0x96, 0x83,
	0x0e, 0x20, 0x13, 0xb0, 0x4b, 0x67, 0xb5, 0xc8, 0x5b, 0xbe, 0xb4, 0x92, 0x31, 0x74, 0xf4, 0x0b,
	0x28, 0x8d, 0x27, 0x06, 0x36, 0x3d, 0xd5, 0xb4, 0x74, 0x4c, 0x9e, 0x59, 0x82, 0x04, 0x8a, 0x91,
	0x2c, 0x1d, 0xfb, 0x12, 0x2e, 0x76, 0xee, 0xb1, 0x43, 0x25, 0xb2, 0x2b, 0x24, 0x28, 0x86, 0x48,
	0xb4, 0x80, 0x0b, 0xde, 0x70, 0x8d, 0x5b, 0x53, 0xf3, 0x66, 0x0e, 0xae, 0xe7, 0x88, 0xd8, 0x6e,
	0x44, 0x4c, 0xee, 0xca, 0x83, 0x90, 0xad, 0xd4, 0xa8, 0xc0, 0x9c, 0xd0, 0xfc, 0x4b, 0x06, 0x72,
	0x44, 0xd9, 0xcb, 0x88, 0xcb, 0x4b, 0xde, 0x25, 0x4c, 0x74, 0x0c, 0x1c, 0x49, 0xf8, 0xd8, 0x9a,
	0xa8, 0xf7, 0xd8, 0x71, 0x0d, 0xcb, 0x0c, 0xb2, 0x52, 0x0b, 0xe9, 0x97, 0x94, 0x8c, 0xbe, 0x00,
	0x30, 0x6c, 0x35, 0xcc, 0x4a, 0x76, 0x4d, 0x56, 0x58, 0xc3, 0x0e, 0xeb, 0xa5, 0x05, 0xb5, 0xb1,
	0x65, 0x7a, 0xda, 0xd8, 0x53, 0x75, 0xec, 0x69, 0xc6, 0xc4, 0x0d, 0x1c, 0xda, 0x8b, 0x48, 0xb6,
	0x29, 0xa2, 0x43, 0x01, 0x4a, 0x75, 0x1c, 0xbb, 0x23, 0x0e, 0xb2, 0xfc, 0x40, 0xaa, 0xe7, 0x49,
	0x62, 0xfd, 0xa3, 0x6f, 0x8a, 0x7d, 0x6b, 0xab, 0xd8, 0xf4, 0x0c, 0xef, 0xa1, 0x5e, 0x48, 0x99,
	0x22, 0x77, 0x65, 0x81, 0xf0, 0x14, 0xd6, 0xbe, 0xb5, 0xe9, 0xb1, 0xf9, 0x8f, 0x2c, 0x54, 0xe3,
	0x2f, 0xa1, 0x57, 0xb0, 0x65, 0x39, 0xb7, 0x9a, 0x69, 0x7c, 0xa7, 0x79, 0x86, 0x65, 0xaa, 0xa6,
	0x36, 0xc5, 0x41, 0x89, 0x70, 0x51, 0x86, 0xa4, 0x4d, 0xfd, 0x78, 0x56, 0xf0, 0x54, 0x33, 0x26,
	0x6a, 0xbc, 0x7a, 0xcb, 0x84, 0x18, 0xfa, 0xfb, 0x02, 0xca, 0xf6, 0x9d, 0x65, 0x62, 0xd5, 0x9c,
	0x4d, 0xaf, 0xb1, 0x43, 0xc2, 0xc4, 0x2a, 0x25, 0x42, 0x93, 0x08, 0x89, 0x84, 0xfc, 0xee, 0xc1,
	0x35, 0xc6, 0xda, 0x42, 0x55, 0x2e, 0x08, 0x79, 0x40, 0x0f, 0xb5, 0x89, 0x8b, 0xe8, 0xd9, 0xd8,
	0x71, 0x2d, 0xd3, 0xad, 0xe7, 0x0f, 0xb3, 0x47, 0xa5, 0xb3, 0xc3, 0x95, 0xd1, 0x3b, 0x95, 0x09,
	0x70, 0x1e, 0x44, 0x7a, 0x75, 0x1b, 0xff, 0x64, 0xa0, 0x40, 0xcf, 0xe8, 0x39, 0xc0, 0x8d, 0xe1,
	0xb8, 0x1e, 0x75, 0xb7, 0x40, 0x9e, 0x66, 0x09, 0x85, 0xf8, 0x79, 0x00, 0xa5, 0xa9, 0xa1, 0xeb,
	0x13, 0x4c, 0xf9, 0x9b, 0x84, 0x0f, 0x94, 0x44, 0x00, 0x3f, 0x01, 0x76, 0xa2, 0x85, 0xe2, 0x45,
	0xc2, 0x2e, 0xfa, 0x84, 0x90, 0xf9, 0xde, 0xba, 0x56, 0x3d, 0xc3, 0x9b, 0xe0, 0x3a, 0x4b, 0x99,
	0xef, 0xad, 0xeb, 0xa1, 0x7f, 0x4f, 0x87, 0x10, 0x9e, 0x10, 0xc2, 0x52, 0x2a, 0x84, 0xcd, 0xcf,
	0x81, 0x9d, 0xa7, 0xd8, 0xb7, 0xd7, 0x2f, 0x06, 0x5b, 0x1b, 0x7f, 0x8b, 0x3d, 0x3a, 0x2e, 0xca,
	0x8a, 0x5f, 0x1f, 0x32, 0xa5, 0x34, 0x3f, 0x87, 0x72, 0xb4, 0x65, 0xd0, 0x3e, 0xb0, 0x8b, 0xf6,
	0xa2, 0xf0, 0x05, 0xa1, 0xf9, 0x7d, 0x11, 0x0a, 0x0a, 0xb6, 0x2d, 0xc7, 0x7b, 0x5a, 0x07, 0xbd,
	0x82, 0xa2, 0x43, 0xe0, 0xd8, 0x59, 0x35, 0x14, 0xe6, 0x00, 0x74, 0x0c, 0x9b, 0xee, 0xcc, 0xb5,
	0xf1, 0xd8, 0x5b, 0x35, 0x0e, 0x42, 0x3e, 0xfa, 0x32, 0x6a, 0xe5, 0x23, 0x43, 0x60, 0x81, 0x44,
	0xbf, 0x85, 0xbd, 0x99, 0xe9, 0x7a, 0x9a, 0xa9, 0x6b, 0x8e, 0x6e, 0x7c, 0x87, 0x75, 0x95, 0xc8,
	0xa8, 0xde, 0x83, 0x8d, 0x49, 0x0b, 0xb1, 0xbd, 0x0d, 0x65, 0x37, 0x0e, 0xe1, 0x7d, 0xc4, 0xf0,
	0xc1, 0xc6, 0xe8, 0x4b, 0x80, 0x08, 0xbc, 0x40, 0x46, 0x7b, 0xb4, 0xb1, 0xe6, 0xc8, 0xde, 0x86,
	0x42, 0x57, 0x04, 0x11, 0x3b, 0x84, 0x92, 0x8e, 0xdd, 0xb1, 0x63, 0xd8, 0x7e, 0xb7, 0x04, 0x25,
	0x13, 0x25, 0xa1, 0x1d, 0xc8, 0x93, 0x24, 0xd3, 0x7a, 0xe9, 0x31, 0x0a, 0xbd, 0xa2, 0x17, 0x50,
	0xd2, 0xad, 0xa9, 0x66, 0x04, 0xbd, 0xc7, 0x06, 0x5c, 0xa0, 0x44, 0x52, 0x51, 0x08, 0xb2, 0x33,
	0x67, 0x42, 0x4b, 0xa5, 0xc7, 0x28, 0xfe, 0x05, 0x7d, 0x06, 0x19, 0xc3, 0x26, 0x95, 0xb1, 0x62,
	0x06, 0xf5, 0x18, 0x25, 0x63, 0xd8, 0xe8, 0xe7, 0x50, 0x34, 0x6c, 0xd5, 0xf1, 0x57, 0x4a, 0xbd,
	0x4c, 0xd0, 0x28, 0x86, 0x26, 0xcb, 0xa6, 0xc7, 0x28, 0x9b, 0x86, 0x4d, 0xf7, 0xce, 0x57, 0x50,
	0xc4, 0xf7, 0x86, 0x8e, 0xcd, 0x31, 0xae, 0x57, 0x48, 0xab, 0x1d, 0x44, 0x04, 0x68, 0x5d, 0x9c,
	0x0a, 0x01, 0x42, 0x30, 0x3d, 0xe7, 0x41, 0x99, 0x0b, 0xa0, 0xdf, 0xc3, 0xf6, 0x22, 0x7a, 0xea,
	0x14, 0x7b, 0x9a, 0xae, 0x79, 0x5a, 0xbd, 0x4a, 0xf4, 0x1c, 0xa5, 0xf5, 0xcc, 0xa3, 0x79, 0x1e,
	0x40, 0xa9, 0xc2, 0x2d, 0x2d, 0x49, 0x47, 0x5f, 0x03, 0xa7, 0x63, 0x0f, 0x8f, 0xc9, 0x94, 0x9a,
	0x62, 0xef, 0xce, 0xd2, 0xeb, 0x35, 0xe2, 0xcf, 0x41, 0x32, 0x3b, 0x9d, 0x10, 0x77, 0x4e, 0x60,
	0x4a, 0x4d, 0x8f, 0x13, 0xd0, 0x7b, 0xd8, 0x4b, 0xea, 0x5a, 0xd8, 0xca, 0x11, 0x5b, 0x4f, 0xd3,
	0xb6, 0x26, 0xd4, 0xc6, 0x2d, 0xde, 0xd5, 0x97, 0x73, 0x1b, 0x32, 0x54, 0x62, 0xc1, 0xf2, 0x67,
	0xf9, 0xb7, 0xf8, 0x21, 0x98, 0xb1, 0xfe, 0x11, 0x1d, 0x43, 0xfe, 0x5e, 0x9b, 0xcc, 0xc2, 0x8d,
	0xba, 0x1d, 0x79, 0x3a, 0x14, 0x55, 0x28, 0xe2, 0x6d, 0xe6, 0xd7, 0x4c, 0xa3, 0x03, 0x3b, 0xcb,
	0xc3, 0xb6, 0x44, 0xf5, 0xb3, 0xa8, 0x6a, 0x36, 0xaa, 0xe5, 0x6b, 0xd8, 0x5f, 0xe7, 0xd0, 0x0f,
	0xd1, 0xd5, 0xda, 0x86, 0x2d, 0xda, 0xdf, 0x91, 0x4e, 0x6b, 0x55, 0xa1, 0x4c, 0x6f, 0x96, 0x63,
	0xdc, 0x1a, 0x66, 0xf3, 0xcf, 0x79, 0x40, 0x34, 0x92, 0x6d, 0xcb, 0xbc, 0x31, 0x9c, 0x29, 0xd9,
	0x2b, 0x4f, 0x9b, 0x30, 0x2f, 0x21, 0xb7, 0xee, 0x27, 0x07, 0x61, 0xa2, 0x9f, 0x41, 0x81, 0x5a,
	0xb1, 0x6a, 0xb0, 0x04, 0xec, 0x0f, 0x9d, 0x2b, 0x89, 0x16, 0xcf, 0xa7, 0x5b, 0xbc, 0x1b, 0x69,
	0x9d, 0x02, 0x29, 0xa3, 0x57, 0xa9, 0x32, 0x8a, 0x3a, 0xbf, 0xb2, 0x8d, 0x96, 0x15, 0xfb, 0xe6,
	0x07, 0x16, 0xfb, 0xfd, 0xba, 0x62, 0x2f, 0x12, 0x2b, 0xdf, 0xae, 0xb7, 0xf2, 0xc7, 0x52, 0xf8,
	0xff, 0xc3, 0x92, 0x6d, 0xfe, 0x9b, 0x81, 0x67, 0xcb, 0xe2, 0x87, 0x7a, 0x70, 0x90, 0xd8, 0x1e,
	0xa9, 0x4c, 0x30, 0xc1, 0x0e, 0x79, 0x1e, 0x07, 0x26, 0x35, 0x5d, 0xc1, 0x27, 0xa9, 0xc0, 0x93,
	0xa5, 0x92, 0x21, 0x4b, 0xe5, 0xe5, 0x23, 0x99, 0x0c, 0x76, 0xcc, 0xb6, 0x9e, 0x26, 0xb7, 0x50,
	0xba, 0x3e, 0x9a, 0x7f, 0x63, 0xa0, 0x18, 0x46, 0x0d, 0xb5, 0x60, 0x3f, 0xe1, 0x45, 0x58, 0x5b,
	0xd4, 0x84, 0xd0, 0x85, 0x46, 0x1c, 0x15, 0xca, 0x93, 0x95, 0xf6, 0x1a, 0x72, 0x11, 0x73, 0x77,
	0x97, 0x24, 0x27, 0x30, 0x91, 0xc0, 0xc8, 0x2f, 0x9b, 0xf0, 0x0d, 0x52, 0x5b, 0x59, 0xf2, 0xbb,
	0xa2, 0x1c, 0x12, 0x3b, 0x9a, 0xa7, 0xb5, 0x6a, 0x11, 0x90, 0x2f, 0xd5, 0xfc, 0x4f, 0x16, 0x2a,
	0x1d, 0x3c, 0x31, 0x5c, 0x4f, 0xc1, 0x7f, 0x98, 0x61, 0xf7, 0x89, 0x3f, 0x39, 0x16, 0xbd, 0x9e,
	0x59, 0xdf, 0xeb, 0xe1, 0xe4, 0x48, 0x8f, 0x04, 0xff, 0x0b, 0x21, 0x98, 0x1c, 0x1f, 0x6d, 0x20,
	0xb4, 0x52, 0x03, 0xe1, 0xb3, 0x88, 0xde, 0x98, 0xdf, 0x2b, 0x67, 0x41, 0x0b, 0x8a, 0xf3, 0x76,
	0xdd, 0x7c, 0x44, 0x47, 0xbc, 0x35, 0xe7, 0x72, 0x1f, 0xa1, 0x17, 0xbf, 0x82, 0xca, 0x87, 0x37,
	0xdf, 0x5f, 0xf3, 0xc0, 0x51, 0xc3, 0xf9, 0xf1, 0x18, 0xdb, 0x9e, 0xe6, 0xfb, 0xf9, 0xa4, 0xbc,
	0xbf, 0x81, 0xaa, 0x4e, 0x04, 0x55, 0x87, 0xba, 0xbc, 0x2a, 0xff, 0x15, 0x3d, 0x59, 0x54, 0xff,
	0xc7, 0x32, 0x10, 0x52, 0x65, 0x70, 0x9c, 0x4a, 0xe1, 0x22, 0x12, 0x2b, 0x2b, 0x41, 0x82, 0x2d,
	0x6d, 0x8e, 0x8a, 0xaf, 0x85, 0x17, 0x6b, 0xf4, 0x05, 0x8b, 0x81, 0xd3, 0x12, 0x14, 0xf4, 0x47,
	0x68, 0xa4, 0xf4, 0x25, 0x57, 0xc3, 0x6f, 0xd6, 0x19, 0x9a, 0x7c, 0x23, 0x5e, 0x7e, 0x75, 0x6d,
	0x05, 0xfb, 0x23, 0x94, 0xe3, 0x37, 0xf0, 0x7c, 0xad, 0x31, 0x3f, 0xa8, 0x3c, 0xff, 0xc5, 0xc0,
	0xce, 0xf2, 0x20, 0xa2, 0x01, 0x7c, 0x9a, 0xfc, 0xb6, 0x48, 0x45, 0x30, 0x36, 0x60, 0x9b, 0x89,
	0xef, 0x8c, 0x84, 0x42, 0x32, 0x68, 0x7b, 0x50, 0x4a, 0xaf, 0x87, 0x4f, 0x1f, 0xcd, 0x68, 0x30,
	0x7d, 0x61, 0xba, 0xd8, 0x0b, 0xdb, 0x4b, 0x2a, 0xe4, 0xe4, 0x57, 0x50, 0x4b, 0xfc, 0x1f, 0x85,
	0xb6, 0xa0, 0x22, 0xca, 0xef, 0xf8, 0x73, 0xb1, 0x7f, 0xa5, 0x8a, 0xf2, 0xe5, 0x2f, 0xb9, 0x8d,
	0x24, 0xe9, 0x0d, 0xc7, 0x9c, 0xbc, 0x81, 0xfa, 0xaa, 0xc5, 0x84, 0x1a, 0xb0, 0xc3, 0xb7, 0x46,
	0x03, 0x41, 0xed, 0x08, 0x43, 0xa1, 0x3d, 0x14, 0x2f, 0x24, 0xf5, 0x9c, 0x97, 0x46, 0x7c, 0x9f,
	0xdb, 0x38, 0xb9, 0x82, 0x72, 0x6c, 0x91, 0x70, 0x50, 0x16, 0x2e, 0xc5, 0x8e, 0x20, 0xb5, 0x05,
	0x75, 0xa4, 0xf4, 0xb9, 0x8d, 0x18, 0xa5, 0x7f, 0xd1, 0xe5, 0x18, 0x84, 0xa0, 0x3a, 0xa7, 0x88,
	0xe7, 0x7c, 0x57, 0xe0, 0x32, 0xbe, 0x49, 0x73, 0x9a, 0xdc, 0xe6, 0x65, 0x2e, 0x7b, 0xf2, 0x77,
	0x06, 0xd8, 0xc5, 0xb7, 0x5a, 0x15, 0x80, 0x1a, 0x31, 0x90, 0xf9, 0x73, 0x6e, 0xc3, 0x57, 0x42,
	0xef, 0x72, 0x4f, 0x1c, 0xf4, 0x44, 0xc9, 0x57, 0x5c, 0x01, 0x36, 0x30, 0xf4, 0x62, 0xc0, 0x65,
	0xd0, 0x21, 0xec, 0xd3, 0x6b, 0xfb, 0x42, 0xbe, 0x52, 0xc4, 0x6e, 0x6f, 0xa8, 0x8a, 0xd2, 0x3b,
	0x45, 0x94, 0xba, 0xc2, 0xb9, 0x20, 0x0d, 0xb9, 0x2c, 0xda, 0x83, 0x4f, 0x28, 0x42, 0xec, 0xf7,
	0x85, 0x2e, 0xdf, 0x57, 0xdb, 0x17, 0xd2, 0xd0, 0x67, 0xe5, 0xd0, 0x4f, 0xa1, 0x41, 0x59, 0x23,
	0x69, 0xc0, 0x4b, 0xc4, 0x6b, 0xa1, 0xa3, 0xf6, 0xf8, 0xf6, 0x37, 0xfe, 0x5b, 0x79, 0xb4, 0x0f,
	0x75, 0xca, 0xbf, 0x14, 0x95, 0xd1, 0x40, 0xed, 0x88, 0x83, 0xa1, 0x22, 0xb6, 0x46, 0x3e, 0x8e,
	0x2b, 0x9c, 0xbc, 0x85, 0xc6, 0xea, 0x44, 0xfa, 0xb2, 0x1d, 0xa1, 0x2f, 0x0e, 0x86, 0x2a, 0xdf,
	0x6e, 0x0b, 0xf2, 0x90, 0xf7, 0xbd, 0x0e, 0x43, 0x7a, 0x5d, 0x20, 0x7f, 0x45, 0x7d, 0xf1, 0xdf,
	0x00, 0x00, 0x00, 0xff, 0xff, 0xe6, 0x49, 0x3c, 0x34, 0xae, 0x14, 0x00, 0x00,
}
